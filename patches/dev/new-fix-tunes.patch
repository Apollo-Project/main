--- git.orig/src/src.pri
+++ git/src/src.pri
@@ -29,7 +29,7 @@ pep {
  DEFINES += USE_PEP
 	CONFIG += tc_psifile
 	mac { CONFIG += tc_itunes }
-	windows { CONFIG += tc_winamp }
+	windows { CONFIG += tc_aimp tc_winamp }
 	unix:dbus:!mac { CONFIG += tc_mpris }
 }
 include($$PWD/tools/tunecontroller/tunecontroller.pri)
--- git.orig/src/tools/tunecontroller/aimptunecontroller.cpp
+++ git/src/tools/tunecontroller/aimptunecontroller.cpp
@@ -0,0 +1,121 @@
+/*
+ * aimptunecontroller.cpp
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "aimptunecontroller.h"
+#include "third-party/AIMPSDKCommon.h"
+#include "third-party/AIMPSDKRemote.h"
+
+/**
+ * \class AIMPTuneController
+ * \brief A controller class for AIMP3 player.
+ */
+
+static const int PLAYING = 2;
+static const int STOPPED = 0;
+static const WCHAR* AIMP_REMOTE_CLASS = (WCHAR *)L"AIMP2_RemoteInfo";
+
+AIMPTuneController::AIMPTuneController()
+: PollingTuneController(),
+  _tuneSent(false)
+{
+	startPoll();
+}
+
+HWND AIMPTuneController::findAimp() const
+{
+	return FindWindow(AIMP_REMOTE_CLASS, AIMP_REMOTE_CLASS);
+}
+
+int AIMPTuneController::getAimpStatus(const HWND &aimp) const
+{
+	if (aimp) {
+		return (int)SendMessage(aimp, WM_AIMP_PROPERTY, AIMP_RA_PROPERTY_PLAYER_STATE | AIMP_RA_PROPVALUE_GET, 0);
+	}
+	return STOPPED;
+}
+
+void AIMPTuneController::check()
+{
+	HWND aimp = findAimp();
+	if (getAimpStatus(aimp) == PLAYING) {
+		sendTune(getTune());
+	}
+	else {
+		clearTune();
+	}
+	PollingTuneController::check();
+}
+
+Tune AIMPTuneController::currentTune() const
+{
+	return _currentTune;
+}
+
+Tune AIMPTuneController::getTune() const
+{
+	QString title = "";
+	QString album = "";
+	QString artist = "";
+	QString url="";
+	HANDLE aFile=OpenFileMapping(FILE_MAP_READ, TRUE, AIMP_REMOTE_CLASS);
+	TAIMPFileInfo *aInfo=(TAIMPFileInfo *)MapViewOfFile(aFile, FILE_MAP_READ, 0, 0, AIMPRemoteAccessMapFileSize);
+	if (aInfo != NULL) {
+		wchar_t *str = (wchar_t *)((DWORD)aInfo+ aInfo->StructSize);
+		album = QString::fromWCharArray(str, aInfo->AlbumLength);
+		str += aInfo->AlbumLength;
+		artist = QString::fromWCharArray(str, aInfo->ArtistLength);
+		str += aInfo->ArtistLength + aInfo->DateLength;
+		url = QString::fromWCharArray(str, aInfo->FileNameLength);
+		str += aInfo->FileNameLength + aInfo->GenreLength;
+		title = QString::fromWCharArray(str, aInfo->TitleLength);
+	}
+	UnmapViewOfFile(aInfo);
+	CloseHandle(aFile);
+	Tune tune = Tune();
+	if (!title.isEmpty()) {
+		tune.setName(title);
+	}
+	if (!artist.isEmpty()) {
+		tune.setArtist(artist);
+	}
+	if (!album.isEmpty()) {
+		tune.setAlbum(album);
+	}
+	if (!url.isEmpty()) {
+		tune.setURL(url);
+	}
+	return tune;
+}
+
+void AIMPTuneController::sendTune(const Tune &tune)
+{
+	if (tune != _currentTune && !tune.isNull()) {
+		_currentTune = tune;
+		_tuneSent = true;
+	}
+}
+
+void AIMPTuneController::clearTune()
+{
+	if (_tuneSent) {
+		_currentTune = Tune();
+		_tuneSent = false;
+	}
+}
--- git.orig/src/tools/tunecontroller/aimptunecontroller.h
+++ git/src/tools/tunecontroller/aimptunecontroller.h
@@ -0,0 +1,51 @@
+/*
+ * aimptunecontroller.h
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef AIMPTUNECONTROLLER_H
+#define AIMPTUNECONTROLLER_H
+
+#include "pollingtunecontroller.h"
+#include "tune.h"
+#include "windows.h"
+
+class AIMPTuneController : public PollingTuneController
+{
+	Q_OBJECT
+
+public:
+	AIMPTuneController();
+	Tune currentTune() const;
+
+protected slots:
+	void check();
+
+private:
+	Tune getTune() const;
+	HWND findAimp() const;
+	int getAimpStatus(const HWND &aimp) const;
+	void sendTune(const Tune &tune);
+	void clearTune();
+
+private:
+	Tune _currentTune;
+	bool _tuneSent;
+};
+
+#endif
--- git.orig/src/tools/tunecontroller/itunestunecontroller.cpp
+++ git/src/tools/tunecontroller/itunestunecontroller.cpp
@@ -0,0 +1,113 @@
+/*
+ * itunescontroller.cpp 
+ * Copyright (C) 2006  Remko Troncon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QtGlobal>
+#include <QString>
+#include <QTime>
+#include <QDebug>
+
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "itunestunecontroller.h"
+
+/**
+ * \class ITunesController
+ * \brief A controller for the Mac OS X version of iTunes.
+ */
+
+static QString CFStringToQString(CFStringRef s)
+{
+	QString result;
+
+	if (s != NULL) {
+		CFIndex length = CFStringGetMaximumSizeForEncoding(CFStringGetLength(s), kCFStringEncodingUTF8) + 1;
+		char* buffer = new char[length];
+		if (CFStringGetCString(s, buffer, length, kCFStringEncodingUTF8)) {
+			result = QString::fromUtf8(buffer);
+		}
+		else {
+			qWarning("itunesplayer.cpp: CFString conversion failed.");
+		}
+		delete[] buffer;
+	} 
+    return result;
+}
+
+
+ITunesController::ITunesController()
+{
+	// TODO: Poll iTunes for current playing tune
+	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
+	CFNotificationCenterAddObserver(center, this, ITunesController::iTunesCallback, CFSTR("com.apple.iTunes.playerInfo"), NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
+}
+
+ITunesController::~ITunesController()
+{
+	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
+	CFNotificationCenterRemoveObserver(center, this, CFSTR("com.apple.iTunes.playerInfo"), NULL);
+}
+
+Tune ITunesController::currentTune() const
+{
+	return currentTune_;
+}
+
+void ITunesController::iTunesCallback(CFNotificationCenterRef,void* observer,CFStringRef,const void*, CFDictionaryRef info)
+{
+	Tune tune;
+	ITunesController* controller = (ITunesController*) observer;
+	
+	CFStringRef cf_state = (CFStringRef) CFDictionaryGetValue(info, CFSTR("Player State"));
+	if (CFStringCompare(cf_state,CFSTR("Paused"),0) == kCFCompareEqualTo) {
+		//qDebug() << "itunesplayer.cpp: Paused";
+		emit controller->stopped();
+	}
+	else if (CFStringCompare(cf_state,CFSTR("Stopped"),0) == kCFCompareEqualTo) {
+		//qDebug() << "itunesplayer.cpp: Stopped";
+		emit controller->stopped();
+	}
+	else if (CFStringCompare(cf_state,CFSTR("Playing"),0) == kCFCompareEqualTo) {
+		//qDebug() << "itunesplayer.cpp: Playing";
+		tune.setArtist(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Artist"))));
+		tune.setName(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Name"))));
+		tune.setAlbum(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Album"))));
+		
+		CFNumberRef cf_track = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Track Number"));
+		if (cf_track) {
+			int tracknr;
+			if (!CFNumberGetValue(cf_track,kCFNumberIntType,&tracknr)) {
+				qWarning("itunesplayer.cpp: Number value conversion failed.");
+			}
+			tune.setTrack(QString::number(tracknr));
+		}
+		
+		CFNumberRef cf_time = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Total Time"));
+		int time = 0;
+		if (cf_time && !CFNumberGetValue(cf_time,kCFNumberIntType,&time)) {
+			qWarning("itunesplayer.cpp: Number value conversion failed.");
+		}
+		tune.setTime((unsigned int) (time / 1000));
+		controller->currentTune_ = tune;
+		emit controller->playing(tune);
+	}
+	else {
+		qWarning("itunesplayer.cpp: Unknown state.");
+	}
+}
--- git.orig/src/tools/tunecontroller/itunestunecontroller.h
+++ git/src/tools/tunecontroller/itunestunecontroller.h
@@ -0,0 +1,22 @@
+#ifndef ITUNESTUNECONTROLLER_H
+#define ITUNESTUNECONTROLLER_H
+
+#include <QString>
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "tunecontrollerinterface.h"
+
+class ITunesController : public TuneController
+{
+public:
+	ITunesController();
+	~ITunesController();
+
+	virtual Tune currentTune() const;
+
+private:
+	static void iTunesCallback(CFNotificationCenterRef,void*,CFStringRef,const void*, CFDictionaryRef info);
+	Tune currentTune_;
+};
+
+#endif
--- git.orig/src/tools/tunecontroller/plugins/aimp/aimpplugin.cpp
+++ git/src/tools/tunecontroller/plugins/aimp/aimpplugin.cpp
@@ -0,0 +1,56 @@
+/*
+ * aimpplugin.cpp
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef QT_STATICPLUGIN
+#define QT_STATICPLUGIN
+#endif
+
+#include <QtCore>
+#include <QObject>
+#include <QString>
+
+#include "aimptunecontroller.h"
+#include "tunecontrollerplugin.h"
+
+class AIMPPlugin : public QObject, public TuneControllerPlugin
+{
+
+	Q_OBJECT
+
+	Q_INTERFACES(TuneControllerPlugin)
+
+public:
+	virtual QString name();
+	virtual TuneController* createController();
+};
+
+Q_EXPORT_PLUGIN2(aimpplugin, AIMPPlugin);
+
+QString AIMPPlugin::name()
+{
+	return "AIMP3";
+}
+
+TuneController* AIMPPlugin::createController()
+{
+	return new AIMPTuneController();
+}
+
+#include "aimpplugin.moc"
--- git.orig/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKCommon.h
+++ git/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKCommon.h
@@ -0,0 +1,50 @@
+/* ******************************************** */
+/*                                              */
+/*                AIMP Plugins API              */
+/*             v3.00.960 (01.12.2011)           */
+/*                Common Objects                */
+/*                                              */
+/*              (c) Artem Izmaylov              */
+/*                 www.aimp.ru                  */
+/*             Mail: artem@aimp.ru              */
+/*              ICQ: 345-908-513                */
+/*                                              */
+/* ******************************************** */
+
+#ifndef AIMPSDKCommonH
+#define AIMPSDKCommonH
+
+#include <windows.h>
+#include <unknwn.h>
+
+#pragma pack(push, 1)
+struct TAIMPFileInfo
+{
+	DWORD StructSize;
+	//
+	BOOL  Active;
+	DWORD BitRate;
+	DWORD Channels;
+	DWORD Duration;
+	INT64 FileSize;
+	DWORD Rating;
+	DWORD SampleRate;
+	DWORD TrackNumber;
+	//
+	DWORD AlbumLength;
+	DWORD ArtistLength;
+	DWORD DateLength;
+	DWORD FileNameLength;
+	DWORD GenreLength;
+	DWORD TitleLength;
+	//
+	PWCHAR Album;
+	PWCHAR Artist;
+	PWCHAR Date;
+	PWCHAR FileName;
+	PWCHAR Genre;
+	PWCHAR Title;
+};
+#pragma pack(pop)
+
+#endif
--- git.orig/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKRemote.h
+++ git/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKRemote.h
@@ -0,0 +1,228 @@
+/* ******************************************** */
+/*                                              */
+/*                AIMP Plugins API              */
+/*             v3.00.960 (01.12.2011)           */
+/*                 Remote Access                */
+/*                                              */
+/*              (c) Artem Izmaylov              */
+/*                 www.aimp.ru                  */
+/*             Mail: artem@aimp.ru              */
+/*              ICQ: 345-908-513                */
+/*                                              */
+/* ******************************************** */
+
+#ifndef AIMPSDKRemoteH
+#define AIMPSDKRemoteH
+
+#include <windows.h>
+
+const char AIMPRemoteAccessClass[] = "AIMP2_RemoteInfo";
+const int  AIMPRemoteAccessMapFileSize = 2048;
+
+// Messages, which you can send to window with "AIMPRemoteAccessClass" class
+// You can receive Window Handle via FindWindow function (see MSDN for details)
+const int WM_AIMP_COMMAND  = WM_USER + 0x75;
+const int WM_AIMP_NOTIFY   = WM_USER + 0x76;
+const int WM_AIMP_PROPERTY = WM_USER + 0x77;
+
+// See AIMP_RA_CMD_GET_COVER_ART command
+const int WM_AIMP_COPYDATA_COVER_ID = 0x41495043;
+
+//==============================================================================
+// + How to:
+//     GET:  SendMessage(Handle, WM_AIMP_PROPERTY, PropertyID | AIMP_RA_PROPVALUE_GET, 0);
+//     SET:  SendMessage(Handle, WM_AIMP_PROPERTY, PropertyID | AIMP_RA_PROPVALUE_SET, NewValue);
+//
+//     Receive Change Notification:
+//       1) You should register notification hook using AIMP_RA_CMD_REGISTER_NOTIFY command
+//       2) When property will change you receive WM_AIMP_NOTIFY message with following params:
+//          WParam: AIMP_RA_NOTIFY_PROPERTY (Notification ID)
+//          LParam: Property ID
+//
+// Properties ID:
+//==============================================================================
+
+const int AIMP_RA_PROPVALUE_GET = 0;
+const int AIMP_RA_PROPVALUE_SET = 1;
+
+const int AIMP_RA_PROPERTY_MASK = 0xFFFFFFF0;
+
+// !! ReadOnly
+// Returns player version:
+// HiWord: Version ID (for example: 301 -> v3.01)
+// LoWord: Build Number
+const int AIMP_RA_PROPERTY_VERSION = 0x10;
+
+// GET: Returns current position of now playing track (in msec)
+// SET: LParam: position (in msec)
+const int AIMP_RA_PROPERTY_PLAYER_POSITION = 0x20;
+
+// !! ReadOnly
+// Returns duration of now playing track (in msec)
+const int AIMP_RA_PROPERTY_PLAYER_DURATION = 0x30;
+
+// !! ReadOnly
+// Returns current player state
+//  0 = Stopped
+//  1 = Paused
+//  2 = Playing
+const int AIMP_RA_PROPERTY_PLAYER_STATE = 0x40;
+
+// GET: Return current volume [0..100] (%)
+// SET: LParam: volume [0..100] (%)
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_VOLUME = 0x50;
+
+// GET: Return current mute state [0..1]
+// SET: LParam: Mute state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_MUTE = 0x60;
+
+// GET: Return track repeat state [0..1]
+// SET: LParam: Track Repeat state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_TRACK_REPEAT = 0x70;
+
+// GET: Return shuffle state [0..1]
+// SET: LParam: shuffle state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_TRACK_SHUFFLE = 0x80;
+
+// GET: Return radio capture state [0..1]
+// SET: LParam: radio capture state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_RADIOCAP = 0x90;
+
+//==============================================================================
+// Commands ID for WM_AIMP_COMMAND message: (Command ID must be defined in WParam)
+//==============================================================================
+
+const int AIMP_RA_CMD_BASE = 10;
+
+// LParam: Window Handle, which will receive WM_AIMP_NOTIFY message from AIMP
+// See description for WM_AIMP_NOTIFY message for details
+const int AIMP_RA_CMD_REGISTER_NOTIFY = AIMP_RA_CMD_BASE + 1;
+
+// LParam: Window Handle
+const int AIMP_RA_CMD_UNREGISTER_NOTIFY = AIMP_RA_CMD_BASE + 2;
+
+// Start / Resume playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PLAY = AIMP_RA_CMD_BASE + 3;
+
+// Pause / Start playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PLAYPAUSE = AIMP_RA_CMD_BASE + 4;
+
+// Pause / Resume playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PAUSE = AIMP_RA_CMD_BASE + 5;
+
+// Stop playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_STOP = AIMP_RA_CMD_BASE + 6;
+
+// Next Track
+const int AIMP_RA_CMD_NEXT = AIMP_RA_CMD_BASE + 7;
+
+// Previous Track
+const int AIMP_RA_CMD_PREV = AIMP_RA_CMD_BASE + 8;
+
+// Next Visualization
+const int AIMP_RA_CMD_VISUAL_NEXT = AIMP_RA_CMD_BASE + 9;
+
+// Previous Visualization
+const int AIMP_RA_CMD_VISUAL_PREV = AIMP_RA_CMD_BASE + 10;
+
+// Close the program
+const int AIMP_RA_CMD_QUIT = AIMP_RA_CMD_BASE + 11;
+
+// Execute "Add files" dialog
+const int AIMP_RA_CMD_ADD_FILES = AIMP_RA_CMD_BASE + 12;
+
+// Execute "Add folders" dialog
+const int AIMP_RA_CMD_ADD_FOLDERS = AIMP_RA_CMD_BASE + 13;
+
+// Execute "Add Playlists" dialog
+const int AIMP_RA_CMD_ADD_PLAYLISTS = AIMP_RA_CMD_BASE + 14;
+
+// Execute "Add URL" dialog
+const int AIMP_RA_CMD_ADD_URL = AIMP_RA_CMD_BASE + 15;
+
+// Execute "Open Files" dialog
+const int AIMP_RA_CMD_OPEN_FILES = AIMP_RA_CMD_BASE + 16;
+
+// Execute "Open Folders" dialog
+const int AIMP_RA_CMD_OPEN_FOLDERS = AIMP_RA_CMD_BASE + 17;
+
+// Execute "Open Playlist" dialog
+const int AIMP_RA_CMD_OPEN_PLAYLISTS = AIMP_RA_CMD_BASE + 18;
+
+// CoverArt Request
+//   LParam: Window Handle, which will process WM_COPYDATA message from AIMP with CoverArt data
+//   Result: 0, if player doesn't play anything or cover art unavailable
+//
+// How to use it:
+//
+//  1. You should send request to AIMP
+//
+//    SendMessage(AIMPWndHandle, WM_AIMP_COMMAND, AIMP_RA_CMD_GET_COVER_ART, Form1.Handle);
+//
+//  2. And AIMP will answer to you via WM_COPYDATA message:
+//
+//    CopyDataStruct.dwData: SyncWord - must be WM_AIMP_COPYDATA_COVER_ID
+//    CopyDataStruct.lpData: Pointer to Image Data (in PNG format)
+//    CopyDataStruct.cbData: Size Of Image Data (in bytes)
+//
+//    procedure TForm1.WMCopyData(var Message: TWMCopyData);
+//    var
+//      AImage: TPngImage;
+//      AStream: TMemoryStream;
+//    begin
+//      if Message.CopyDataStruct^.dwData = WM_AIMP_COPYDATA_COVER_ID then
+//      begin
+//        AStream := TMemoryStream.Create;
+//        try
+//          AStream.WriteBuffer(Message.CopyDataStruct^.lpData^, Message.CopyDataStruct^.cbData);
+//          AStream.Position := 0;
+//          AImage := TPngImage.Create;
+//          try
+//            AImage.LoadFromStream(AStream);
+//            Image1.Picture.Graphic := AImage;
+//          except
+//            Image1.Picture.Graphic := nil;
+//            AImage.Free;
+//          end;
+//        finally
+//          AStream.Free;
+//        end;
+//      end;
+//    end;
+//
+const int AIMP_RA_CMD_GET_COVER_ART = AIMP_RA_CMD_BASE + 19;
+
+//==============================================================================
+// Notifications ID for WM_AIMP_NOTIFY message: (Notification ID in WParam)
+//==============================================================================
+
+const int AIMP_RA_NOTIFY_BASE = 0;
+
+// Called, if information about now playing file has been changed
+// You can read the information in the following manner:
+//
+// var
+//   AInfo: PAIMPFileInfo;
+// begin
+//   AFile := OpenFileMapping(FILE_MAP_READ, True, AIMPRemoteAccessClass);
+//   AInfo := MapViewOfFile(AFile, FILE_MAP_READ, 0, 0, AIMPRemoteAccessMapFileSize);
+//   ...
+const int AIMP_RA_NOTIFY_TRACK_INFO = AIMP_RA_NOTIFY_BASE + 1;
+
+// Called, when audio stream starts playing or when an Internet radio station changes the track
+const int AIMP_RA_NOTIFY_TRACK_START = AIMP_RA_NOTIFY_BASE + 2;
+
+// Called, when property has been changed
+// LParam: Property ID
+const int AIMP_RA_NOTIFY_PROPERTY = AIMP_RA_NOTIFY_BASE + 3; 
+
+#endif
--- git.orig/src/tools/tunecontroller/plugins/itunes/itunescontroller.cpp
+++ git/src/tools/tunecontroller/plugins/itunes/itunescontroller.cpp
@@ -1,113 +0,0 @@
-/*
- * itunescontroller.cpp 
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <QtGlobal>
-#include <QString>
-#include <QTime>
-#include <QDebug>
-
-#include <CoreFoundation/CoreFoundation.h>
-
-#include "itunescontroller.h"
-
-/**
- * \class ITunesController
- * \brief A controller for the Mac OS X version of iTunes.
- */
-
-static QString CFStringToQString(CFStringRef s)
-{
-	QString result;
-
-	if (s != NULL) {
-		CFIndex length = CFStringGetMaximumSizeForEncoding(CFStringGetLength(s), kCFStringEncodingUTF8) + 1;
-		char* buffer = new char[length];
-		if (CFStringGetCString(s, buffer, length, kCFStringEncodingUTF8)) {
-			result = QString::fromUtf8(buffer);
-		}
-		else {
-			qWarning("itunesplayer.cpp: CFString conversion failed.");
-		}
-		delete[] buffer;
-	} 
-    return result;
-}
-
-
-ITunesController::ITunesController()
-{
-	// TODO: Poll iTunes for current playing tune
-	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
-	CFNotificationCenterAddObserver(center, this, ITunesController::iTunesCallback, CFSTR("com.apple.iTunes.playerInfo"), NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
-}
-
-ITunesController::~ITunesController()
-{
-	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
-	CFNotificationCenterRemoveObserver(center, this, CFSTR("com.apple.iTunes.playerInfo"), NULL);
-}
-
-Tune ITunesController::currentTune() const
-{
-	return currentTune_;
-}
-
-void ITunesController::iTunesCallback(CFNotificationCenterRef,void* observer,CFStringRef,const void*, CFDictionaryRef info)
-{
-	Tune tune;
-	ITunesController* controller = (ITunesController*) observer;
-	
-	CFStringRef cf_state = (CFStringRef) CFDictionaryGetValue(info, CFSTR("Player State"));
-	if (CFStringCompare(cf_state,CFSTR("Paused"),0) == kCFCompareEqualTo) {
-		//qDebug() << "itunesplayer.cpp: Paused";
-		emit controller->stopped();
-	}
-	else if (CFStringCompare(cf_state,CFSTR("Stopped"),0) == kCFCompareEqualTo) {
-		//qDebug() << "itunesplayer.cpp: Stopped";
-		emit controller->stopped();
-	}
-	else if (CFStringCompare(cf_state,CFSTR("Playing"),0) == kCFCompareEqualTo) {
-		//qDebug() << "itunesplayer.cpp: Playing";
-		tune.setArtist(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Artist"))));
-		tune.setName(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Name"))));
-		tune.setAlbum(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Album"))));
-		
-		CFNumberRef cf_track = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Track Number"));
-		if (cf_track) {
-			int tracknr;
-			if (!CFNumberGetValue(cf_track,kCFNumberIntType,&tracknr)) {
-				qWarning("itunesplayer.cpp: Number value conversion failed.");
-			}
-			tune.setTrack(QString::number(tracknr));
-		}
-		
-		CFNumberRef cf_time = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Total Time"));
-		int time = 0;
-		if (cf_time && !CFNumberGetValue(cf_time,kCFNumberIntType,&time)) {
-			qWarning("itunesplayer.cpp: Number value conversion failed.");
-		}
-		tune.setTime((unsigned int) (time / 1000));
-		controller->currentTune_ = tune;
-		emit controller->playing(tune);
-	}
-	else {
-		qWarning("itunesplayer.cpp: Unknown state.");
-	}
-}
--- git.orig/src/tools/tunecontroller/plugins/itunes/itunescontroller.h
+++ git/src/tools/tunecontroller/plugins/itunes/itunescontroller.h
@@ -1,22 +0,0 @@
-#ifndef ITUNESCONTROLLER_H
-#define ITUNESCONTROLLER_H
-
-#include <QString>
-#include <CoreFoundation/CoreFoundation.h>
-
-#include "tunecontrollerinterface.h"
-
-class ITunesController : public TuneController
-{
-public:
-	ITunesController();
-	~ITunesController();
-
-	virtual Tune currentTune() const;
-
-private:
-	static void iTunesCallback(CFNotificationCenterRef,void*,CFStringRef,const void*, CFDictionaryRef info);
-	Tune currentTune_;
-};
-
-#endif
--- git.orig/src/tools/tunecontroller/plugins/itunes/itunesplugin.cpp
+++ git/src/tools/tunecontroller/plugins/itunes/itunesplugin.cpp
@@ -26,7 +26,7 @@
 #include <QObject>
 #include <QString>
 
-#include "itunescontroller.h"
+#include "itunestunecontroller.h"
 #include "tunecontrollerplugin.h"
 
 class ITunesPlugin : public QObject, public TuneControllerPlugin
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampcontroller.cpp
+++ git/src/tools/tunecontroller/plugins/winamp/winampcontroller.cpp
@@ -1,196 +0,0 @@
-/*
- * winampcontroller.cpp 
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <windows.h>
-#include <QTimer>
-
-#ifdef Q_CC_MSVC
-#pragma warning(push)
-#pragma warning(disable: 4100)
-#endif
-
-// this file generates eight C4100 warnings, when compiled with MSVC2003
-#include "third-party/wa_ipc.h"
-
-#ifdef Q_CC_MSVC
-#pragma warning(pop)
-#endif
-
-#include "winampcontroller.h"
-
-
-/**
- * \class WinAmpController
- * \brief A controller for WinAmp.
- */
-
-
-/**
- * \brief Constructs the controller.
- */
-WinAmpController::WinAmpController() : TuneController()
-{
-	connect(&timer_, SIGNAL(timeout()), SLOT(check()));
-	norminterval_ = 3000;
-	antiscrollinterval_ = 100;
-	antiscrollcounter_ = 0;
-	timer_.start(norminterval_);
-}
-
-template <typename char_type> const size_t length (const char_type * begin)
-{
-	const char_type * end = begin;
-	for (; *end; ++end);
-	return end - begin;
-}
-
-// Returns a title of a track currently being played by WinAmp with given HWND (passed in waWnd)
-QPair<bool, QString> WinAmpController::getTrackTitle(HWND waWnd)
-{
-	TCHAR waTitle[2048];
-	QString title;
-
-	// Get WinAmp window title. It always contains name of the track
-	SendMessage (waWnd, WM_GETTEXT, static_cast<WPARAM> (sizeof (waTitle) / sizeof (waTitle[0])), reinterpret_cast<LPARAM> (waTitle));
-	// Now, waTitle contains WinAmp window title
-	title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle));
-	if (title[0] == '*' || (title.length () && title[title.length() - 1] == '*')) {
-		// request to be called again soon.
-		return QPair<bool, QString>(false, QString());
-	}
-
-	// Check whether there is a need to do the all stuff
-	if (!title.length()) {
-		return QPair<bool, QString>(true,title);
-	}
-
-	QString winamp (" - Winamp ***");
-	int winampLength = winamp.length();
-
-	// Is title scrolling on the taskbar enabled?
-	title += title + title;
-	int waLast = title.indexOf (winamp, -1);
-	if (waLast != -1) {
-		if (title.length()) {
-			title.remove (waLast, title.length () - waLast);
-		}
-		int waFirst;
-		while ((waFirst = title.indexOf (winamp)) != -1) {
-			title.remove (0, waFirst + winampLength);
-		}
-	}
-	else {
-		title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle)); // Title is not scrolling
-	}
-
-	// Remove leading and trailing spaces
-	title  = title.trimmed();
-
-	// Remove trailing " - Winamp" from title
-	if (title.length ()) {
-		winamp = " - Winamp";
-		winampLength = winamp.length ();
-		int waFirst = title.indexOf (winamp);
-		if (waFirst != -1)
-		{
-			title.remove (waFirst, waFirst + winampLength);
-		}
-	}
-
-	// Remove track number from title
-	if (title.length ()) {
-		QString dot(". ");
-		int dotFirst = title.indexOf (dot);
-		if (dotFirst != -1) {
-			// All symbols before the dot are digits?
-			bool allDigits = true;
-			for (int pos = dotFirst; pos > 0; --pos) {
-				allDigits = allDigits && title[pos].isNumber();
-			}
-			if (allDigits) {
-				title.remove(0, dotFirst + dot.length ());
-			}
-		}
-	}
-
-	// Remove leading and trailing spaces
-	if (title.length ()) {
-		while (title.length () && title[0] == ' ') {
-			title.remove (0, 1);
-		}
-		while (title.length () && title[title.length () - 1] == ' ') {
-			title.remove (title.length () - 1, 1);
-		}
-	}
-
-	return QPair<bool, QString>(true,title);
-}
-
-
-/**
- * Polls for new song info.
- */
-void WinAmpController::check()
-{
-
-	Tune tune;
-#ifdef UNICODE
-	HWND h = FindWindow(L"Winamp v1.x", NULL);
-#else
-	HWND h = FindWindow("Winamp v1.x", NULL);
-#endif
-
-	if (h && SendMessage(h,WM_WA_IPC,0,IPC_ISPLAYING) == 1) {
-		QPair<bool, QString> trackpair(getTrackTitle(h));
-		if (!trackpair.first) {
-			// getTrackTitle wants us to retry in a few ms...
-			int interval = antiscrollinterval_;
-			if (++antiscrollcounter_ > 10) {
-				antiscrollcounter_ = 0;
-				interval = norminterval_;
-			}
-			timer_.start(interval);
-			return;
-		}
-		antiscrollcounter_ = 0;
-		tune.setName(trackpair.second);
-		tune.setURL(trackpair.second);
-		tune.setTime(SendMessage(h,WM_WA_IPC,1,IPC_GETOUTPUTTIME));
-	}
-
-
-
-	if (prev_tune_ != tune) {
-		prev_tune_ = tune;
-		if (tune.isNull()) {
-			emit stopped();
-		}
-		else {
-			emit playing(tune);
-		}
-	}
-	timer_.start(norminterval_);
-}
-
-
-Tune WinAmpController::currentTune() const
-{
-	return prev_tune_;
-}
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampcontroller.h
+++ git/src/tools/tunecontroller/plugins/winamp/winampcontroller.h
@@ -1,49 +0,0 @@
-/*
- * winampcontroller.h
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#ifndef WINAMPCONTROLLER_H
-#define WINAMPCONTROLLER_H
-
-#include "tunecontrollerinterface.h"
-#include "pollingtunecontroller.h"
-
-#include <windows.h>
-#include <QPair>
-
-class WinAmpController : public TuneController
-{
-	Q_OBJECT
-public:
-	WinAmpController();
-	virtual Tune currentTune() const;
-
-protected:
-	QPair<bool, QString> getTrackTitle(HWND waWnd);
-protected slots:
-	void check();
-
-private:
-	Tune prev_tune_;
-	QTimer timer_;
-	int norminterval_, antiscrollinterval_;
-	int antiscrollcounter_;
-};
-
-#endif
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampplugin.h
+++ git/src/tools/tunecontroller/plugins/winamp/winampplugin.h
@@ -29,7 +29,7 @@
 #include <QObject>
 #include <QString>
 
-#include "winampcontroller.h"
+#include "winamptunecontroller.h"
 #include "tunecontrollerplugin.h"
 
 class WinAmpPlugin : public QObject, public TuneControllerPlugin
--- git.orig/src/tools/tunecontroller/pollingtunecontroller.h
+++ git/src/tools/tunecontroller/pollingtunecontroller.h
@@ -38,6 +38,7 @@ public:
 	inline bool isPolling() const { return _timer.isActive(); }
 	inline void startPoll() { _timer.start(DefaultInterval); }
 	inline void stopPoll() { _timer.stop(); }
+	inline void setInterval(const int &interval) { _timer.setInterval(interval); }
 
 protected slots:
 	virtual void check();
--- git.orig/src/tools/tunecontroller/tunecontrollermanager.cpp
+++ git/src/tools/tunecontroller/tunecontrollermanager.cpp
@@ -164,6 +164,10 @@ Q_IMPORT_PLUGIN(itunesplugin)
 Q_IMPORT_PLUGIN(winampplugin)
 #endif
 
+#ifdef TC_AIMP
+Q_IMPORT_PLUGIN(aimpplugin)
+#endif
+
 #ifdef TC_PSIFILE
 Q_IMPORT_PLUGIN(psifileplugin)
 #endif
--- git.orig/src/tools/tunecontroller/tunecontroller.pri
+++ git/src/tools/tunecontroller/tunecontroller.pri
@@ -25,10 +25,10 @@ tc_itunes {
 		INCLUDEPATH += $$ITUNES_PLUGIN_PATH
 
 		HEADERS += \
-			$$ITUNES_PLUGIN_PATH/itunescontroller.h 
+			$$PWD/itunestunecontroller.h 
 			
 		SOURCES += \
-			$$ITUNES_PLUGIN_PATH/itunescontroller.cpp \
+			$$PWD/itunestunecontroller.cpp \
 			$$ITUNES_PLUGIN_PATH/itunesplugin.cpp
 
 		QMAKE_LFLAGS += -framework CoreFoundation
@@ -42,11 +42,11 @@ tc_winamp {
 	INCLUDEPATH += $$WINAMP_PLUGIN_PATH
 
 	HEADERS += \
-		$$WINAMP_PLUGIN_PATH/winampcontroller.h \
+		$$PWD/winamptunecontroller.h \
 		$$WINAMP_PLUGIN_PATH/winampplugin.h 
 		
 	SOURCES += \
-		$$WINAMP_PLUGIN_PATH/winampcontroller.cpp \
+		$$PWD/winamptunecontroller.cpp \
 		$$WINAMP_PLUGIN_PATH/winampplugin.cpp
 	
 	LIBS += -lUser32
@@ -78,3 +78,17 @@ tc_mpris {
 		$$PWD/mpristunecontroller.cpp \
 		$$MPRIS_PLUGIN_PATH/mprisplugin.cpp
 }
+
+#AIMP
+tc_aimp {
+	DEFINES += TC_AIMP
+	AIMP_PLUGIN_PATH = $$PWD/plugins/aimp
+	INCLUDEPATH += $$AIMP_PLUGIN_PATH
+
+	HEADERS += \
+		$$PWD/aimptunecontroller.h
+
+	SOURCES += \
+		$$PWD/aimptunecontroller.cpp \
+		$$AIMP_PLUGIN_PATH/aimpplugin.cpp
+}
--- git.orig/src/tools/tunecontroller/winamptunecontroller.cpp
+++ git/src/tools/tunecontroller/winamptunecontroller.cpp
@@ -0,0 +1,191 @@
+/*
+ * winampcontroller.cpp 
+ * Copyright (C) 2006  Remko Troncon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <windows.h>
+
+#ifdef Q_CC_MSVC
+#pragma warning(push)
+#pragma warning(disable: 4100)
+#endif
+
+// this file generates eight C4100 warnings, when compiled with MSVC2003
+#include "third-party/wa_ipc.h"
+
+#ifdef Q_CC_MSVC
+#pragma warning(pop)
+#endif
+
+#include "winamptunecontroller.h"
+
+
+/**
+ * \class WinAmpController
+ * \brief A controller for WinAmp.
+ */
+
+
+/**
+ * \brief Constructs the controller.
+ */
+WinAmpController::WinAmpController()
+: PollingTuneController(),
+  norminterval_(3000),
+  antiscrollinterval_(100),
+  antiscrollcounter_(0)
+{
+	startPoll();
+	setInterval(norminterval_);
+}
+
+template <typename char_type> const size_t length (const char_type * begin)
+{
+	const char_type * end = begin;
+	for (; *end; ++end);
+	return end - begin;
+}
+
+// Returns a title of a track currently being played by WinAmp with given HWND (passed in waWnd)
+QPair<bool, QString> WinAmpController::getTrackTitle(HWND waWnd)
+{
+	TCHAR waTitle[2048];
+	QString title;
+
+	// Get WinAmp window title. It always contains name of the track
+	SendMessage (waWnd, WM_GETTEXT, static_cast<WPARAM> (sizeof (waTitle) / sizeof (waTitle[0])), reinterpret_cast<LPARAM> (waTitle));
+	// Now, waTitle contains WinAmp window title
+	title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle));
+	if (title[0] == '*' || (title.length () && title[title.length() - 1] == '*')) {
+		// request to be called again soon.
+		return QPair<bool, QString>(false, QString());
+	}
+
+	// Check whether there is a need to do the all stuff
+	if (!title.length()) {
+		return QPair<bool, QString>(true,title);
+	}
+
+	QString winamp (" - Winamp ***");
+	int winampLength = winamp.length();
+
+	// Is title scrolling on the taskbar enabled?
+	title += title + title;
+	int waLast = title.indexOf (winamp, -1);
+	if (waLast != -1) {
+		if (title.length()) {
+			title.remove (waLast, title.length () - waLast);
+		}
+		int waFirst;
+		while ((waFirst = title.indexOf (winamp)) != -1) {
+			title.remove (0, waFirst + winampLength);
+		}
+	}
+	else {
+		title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle)); // Title is not scrolling
+	}
+
+	// Remove leading and trailing spaces
+	title  = title.trimmed();
+
+	// Remove trailing " - Winamp" from title
+	if (title.length ()) {
+		winamp = " - Winamp";
+		winampLength = winamp.length ();
+		int waFirst = title.indexOf (winamp);
+		if (waFirst != -1)
+		{
+			title.remove (waFirst, waFirst + winampLength);
+		}
+	}
+
+	// Remove track number from title
+	if (title.length ()) {
+		QString dot(". ");
+		int dotFirst = title.indexOf (dot);
+		if (dotFirst != -1) {
+			// All symbols before the dot are digits?
+			bool allDigits = true;
+			for (int pos = dotFirst; pos > 0; --pos) {
+				allDigits = allDigits && title[pos].isNumber();
+			}
+			if (allDigits) {
+				title.remove(0, dotFirst + dot.length ());
+			}
+		}
+	}
+
+	// Remove leading and trailing spaces
+	if (title.length ()) {
+		while (title.length () && title[0] == ' ') {
+			title.remove (0, 1);
+		}
+		while (title.length () && title[title.length () - 1] == ' ') {
+			title.remove (title.length () - 1, 1);
+		}
+	}
+
+	return QPair<bool, QString>(true,title);
+}
+
+
+/**
+ * Polls for new song info.
+ */
+void WinAmpController::check()
+{
+
+	Tune tune;
+#ifdef UNICODE
+	HWND h = FindWindow(L"Winamp v1.x", NULL);
+#else
+	HWND h = FindWindow("Winamp v1.x", NULL);
+#endif
+
+	if (h && SendMessage(h,WM_WA_IPC,0,IPC_ISPLAYING) == 1) {
+		QPair<bool, QString> trackpair(getTrackTitle(h));
+		if (!trackpair.first) {
+			// getTrackTitle wants us to retry in a few ms...
+			int interval = antiscrollinterval_;
+			if (++antiscrollcounter_ > 10) {
+				antiscrollcounter_ = 0;
+				interval = norminterval_;
+			}
+			setInterval(interval);
+			return;
+		}
+		antiscrollcounter_ = 0;
+		tune.setName(trackpair.second);
+		tune.setURL(trackpair.second);
+		tune.setTime(SendMessage(h,WM_WA_IPC,1,IPC_GETOUTPUTTIME));
+	}
+
+
+
+	if (prev_tune_ != tune) {
+		prev_tune_ = tune;
+	}
+	setInterval(norminterval_);
+	PollingTuneController::check();
+}
+
+
+Tune WinAmpController::currentTune() const
+{
+	return prev_tune_;
+}
--- git.orig/src/tools/tunecontroller/winamptunecontroller.h
+++ git/src/tools/tunecontroller/winamptunecontroller.h
@@ -0,0 +1,47 @@
+/*
+ * winampcontroller.h
+ * Copyright (C) 2006  Remko Troncon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef WINAMPTUNECONTROLLER_H
+#define WINAMPTUNECONTROLLER_H
+
+#include "pollingtunecontroller.h"
+
+#include <windows.h>
+#include <QPair>
+
+class WinAmpController : public PollingTuneController
+{
+	Q_OBJECT
+public:
+	WinAmpController();
+	virtual Tune currentTune() const;
+
+protected:
+	QPair<bool, QString> getTrackTitle(HWND waWnd);
+protected slots:
+	void check();
+
+private:
+	Tune prev_tune_;
+	int norminterval_, antiscrollinterval_;
+	int antiscrollcounter_;
+};
+
+#endif
