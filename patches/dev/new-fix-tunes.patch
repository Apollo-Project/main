--- git.orig/src/options/options.pri
+++ git/src/options/options.pri
@@ -26,7 +26,8 @@ HEADERS += \
 	$$PWD/opt_avcall.h \
 	$$PWD/opt_toolbars.h \
 	$$PWD/opt_advanced.h \
-	$$PWD/opt_shortcuts.h
+	$$PWD/opt_shortcuts.h \
+	$$PWD/opt_statuspep.h
 
 HEADERS += $$PWD/opt_tree.h
 
@@ -46,7 +47,8 @@ SOURCES += \
 	$$PWD/opt_avcall.cpp \
 	$$PWD/opt_toolbars.cpp \
 	$$PWD/opt_advanced.cpp \
-	$$PWD/opt_shortcuts.cpp
+	$$PWD/opt_shortcuts.cpp \
+	$$PWD/opt_statuspep.cpp
 
 SOURCES += $$PWD/opt_tree.cpp
 
@@ -72,7 +74,8 @@ FORMS += \
 	$$PWD/opt_iconset_system.ui \
 	$$PWD/opt_iconset_roster.ui \
 	$$PWD/opt_general_groupchat.ui \
-	$$PWD/opt_shortcuts.ui
+	$$PWD/opt_shortcuts.ui \
+	$$PWD/opt_statuspep.ui
 
 psi_plugins {
 	FORMS += $$PWD/opt_plugins.ui
--- git.orig/src/options/opt_status.cpp
+++ git/src/options/opt_status.cpp
@@ -1,6 +1,7 @@
 #include "opt_status.h"
 #include "opt_statusgeneral.h"
 #include "opt_statusauto.h"
+#include "opt_statuspep.h"
 
 OptionsTabStatus::OptionsTabStatus(QObject *parent)
 : MetaOptionsTab(parent, "status", "", tr("Status"), tr("Status preferences"), "psi/status")
@@ -10,4 +11,5 @@ OptionsTabStatus::OptionsTabStatus(QObje
 	connect(general, SIGNAL(enableDlgCommonWidgets(bool)), parent, SLOT(enableCommonWidgets(bool)));
 	connect(general, SIGNAL(enableDlgCommonWidgets(bool)), SLOT(enableOtherTabs(bool)));
 	addTab(new OptionsTabStatusAuto(this));
+	addTab(new OptionsTabStatusPep(this));
 }
--- git.orig/src/options/opt_statuspep.cpp
+++ git/src/options/opt_statuspep.cpp
@@ -0,0 +1,108 @@
+#include "opt_statuspep.h"
+#include "psioptions.h"
+
+#include <QListWidget>
+#include <QCheckBox>
+
+#include "ui_opt_statuspep.h"
+
+static const char *tuneUrlFilterOptionPath = "options.extended-presence.tune.url-filter";
+static const char *tuneControllerFilterOptionPath = "options.extended-presence.tune.controller-filter";
+
+class OptStatusPepUI : public QWidget, public Ui::OptStatusPep
+{
+public:
+	OptStatusPepUI() : QWidget() { setupUi(this); }
+};
+
+OptionsTabStatusPep::OptionsTabStatusPep(QObject *parent)
+: OptionsTab(parent, "status_tunes", "", tr("PEP"), tr("Tunes no-video filter and controllers switcher"))
+, w_(0)
+, psi_(0)
+, controllersChanged_(false)
+{
+}
+
+OptionsTabStatusPep::~OptionsTabStatusPep()
+{
+}
+
+QWidget *OptionsTabStatusPep::widget()
+{
+	if (w_) {
+		return 0;
+	}
+
+	w_ = new OptStatusPepUI();
+	return w_;
+}
+
+void OptionsTabStatusPep::applyOptions()
+{
+	if (!w_) {
+		return;
+	}
+
+	OptStatusPepUI *d = (OptStatusPepUI *)w_;
+	PsiOptions* o = PsiOptions::instance();
+	QStringList newTuneFilters = d->tuneExtensions->text().split(QRegExp("\\W+"));
+	QString tuneExstensionsFilter;
+	if (!newTuneFilters.isEmpty()) {
+		newTuneFilters.removeDuplicates();
+		qSort(newTuneFilters);
+		tuneExstensionsFilter = newTuneFilters.join(" ").toLower();
+		d->tuneExtensions->setText(tuneExstensionsFilter);
+	}
+	QString controllerFilter = blackList_.join(",");
+	if (tuneExstensionsFilter != tuneFilters_) {
+		o->setOption(tuneUrlFilterOptionPath, tuneExstensionsFilter);
+	}
+	if (controllersChanged_) {
+		o->setOption(tuneControllerFilterOptionPath, controllerFilter);
+	}
+}
+
+void OptionsTabStatusPep::restoreOptions()
+{
+	if (!w_) {
+		return;
+	}
+
+	OptStatusPepUI *d = (OptStatusPepUI *)w_;
+	PsiOptions* o = PsiOptions::instance();
+	tuneFilters_ = o->getOption(tuneUrlFilterOptionPath).toString();
+	d->tuneExtensions->setText(tuneFilters_);
+	QStringList controllers = psi_->tuneManager()->controllerNames();
+	blackList_ = o->getOption(tuneControllerFilterOptionPath).toString().split(QRegExp("[,]\\s*"), QString::SkipEmptyParts);
+	foreach(const QString &name, controllers) {
+		QCheckBox* cb = new QCheckBox(name);
+		QString caption = name + " controller";
+		cb->setText(caption);
+		cb->setObjectName(name);
+		int i = controllers.indexOf(name);
+		d->gridLayout->addWidget(cb,i/3,i%3);
+		cb->setChecked(!blackList_.contains(name));
+		connect(cb, SIGNAL(toggled(bool)), SLOT(controllerSelected(bool)));
+	}
+}
+
+void OptionsTabStatusPep::controllerSelected(bool checked)
+{
+	QCheckBox *box = qobject_cast<QCheckBox*>(sender());
+	QString name_ = box->objectName();
+	if (!name_.isEmpty()) {
+		if (!checked && !blackList_.contains(name_, Qt::CaseInsensitive)) {
+			blackList_ << name_;
+			controllersChanged_ = true;
+		}
+		else if (checked) {
+			blackList_.removeAll(name_);
+			controllersChanged_ = true;
+		}
+	}
+}
+
+void OptionsTabStatusPep::setData(PsiCon *psi, QWidget *)
+{
+	psi_ = psi;
+}
--- git.orig/src/options/opt_statuspep.h
+++ git/src/options/opt_statuspep.h
@@ -0,0 +1,36 @@
+#ifndef OPT_STAUSPEP_H
+#define OPT_STAUSPEP_H
+
+#include "optionstab.h"
+#include "common.h"
+#include "psicon.h"
+
+class QWidget;
+
+class OptionsTabStatusPep : public OptionsTab
+{
+	Q_OBJECT
+
+public:
+
+	OptionsTabStatusPep(QObject *parent);
+	~OptionsTabStatusPep();
+
+	QWidget *widget();
+	void applyOptions();
+	void restoreOptions();
+	void setData(PsiCon *psi, QWidget *);
+
+protected slots:
+	void controllerSelected(bool);
+
+private:
+	QWidget *w_;
+	PsiCon *psi_;
+	QStringList blackList_;
+	QString tuneFilters_;
+	bool controllersChanged_;
+};
+
+
+#endif // OPT_STAUSPEP_H
--- git.orig/src/options/opt_statuspep.ui
+++ git/src/options/opt_statuspep.ui
@@ -0,0 +1,108 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>OptStatusPep</class>
+ <widget class="QWidget" name="OptStatusPep">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>588</width>
+    <height>350</height>
+   </rect>
+  </property>
+  <property name="sizePolicy">
+   <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="windowTitle">
+   <string>Form</string>
+  </property>
+  <property name="autoFillBackground">
+   <bool>false</bool>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <widget class="QGroupBox" name="groupBox">
+     <property name="title">
+      <string>Tunes</string>
+     </property>
+     <property name="alignment">
+      <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+     </property>
+     <property name="flat">
+      <bool>false</bool>
+     </property>
+     <layout class="QVBoxLayout" name="verticalLayout_4">
+      <property name="spacing">
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QLabel" name="label">
+        <property name="text">
+         <string>Enter media file extensions to ignore them on tune sending</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLineEdit" name="tuneExtensions">
+        <property name="toolTip">
+         <string>Add extensions</string>
+        </property>
+        <property name="whatsThis">
+         <string>Ignored media file extensions on psi tunes sending</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QGroupBox" name="rightGroupBox">
+        <property name="sizePolicy">
+         <sizepolicy hsizetype="Expanding" vsizetype="Minimum">
+          <horstretch>0</horstretch>
+          <verstretch>0</verstretch>
+         </sizepolicy>
+        </property>
+        <property name="title">
+         <string>Tune Controllers</string>
+        </property>
+        <property name="flat">
+         <bool>false</bool>
+        </property>
+        <layout class="QVBoxLayout" name="verticalLayout_2">
+         <property name="spacing">
+          <number>0</number>
+         </property>
+         <property name="sizeConstraint">
+          <enum>QLayout::SetDefaultConstraint</enum>
+         </property>
+         <property name="margin">
+          <number>6</number>
+         </property>
+         <item>
+          <layout class="QGridLayout" name="gridLayout"/>
+         </item>
+        </layout>
+       </widget>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <spacer name="verticalSpacer">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>40</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
--- git.orig/src/src.pri
+++ git/src/src.pri
@@ -29,7 +29,7 @@ pep {
 	DEFINES += USE_PEP
 	CONFIG += tc_psifile
 	mac { CONFIG += tc_itunes }
-	windows { CONFIG += tc_winamp }
+	windows { CONFIG += tc_aimp tc_winamp }
 	unix:dbus:!mac { CONFIG += tc_mpris }
 }
 include($$PWD/tools/tunecontroller/tunecontroller.pri)
--- git.orig/src/tools/tunecontroller/aimptunecontroller.cpp
+++ git/src/tools/tunecontroller/aimptunecontroller.cpp
@@ -0,0 +1,121 @@
+/*
+ * aimptunecontroller.cpp
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "aimptunecontroller.h"
+#include "plugins/aimp/third-party/AIMPSDKCommon.h"
+#include "plugins/aimp/third-party/AIMPSDKRemote.h"
+
+/**
+ * \class AIMPTuneController
+ * \brief A controller class for AIMP3 player.
+ */
+
+static const int PLAYING = 2;
+static const int STOPPED = 0;
+static const WCHAR* AIMP_REMOTE_CLASS = (WCHAR *)L"AIMP2_RemoteInfo";
+
+AIMPTuneController::AIMPTuneController()
+: PollingTuneController(),
+  _tuneSent(false)
+{
+	startPoll();
+}
+
+HWND AIMPTuneController::findAimp() const
+{
+	return FindWindow(AIMP_REMOTE_CLASS, AIMP_REMOTE_CLASS);
+}
+
+int AIMPTuneController::getAimpStatus(const HWND &aimp) const
+{
+	if (aimp) {
+		return (int)SendMessage(aimp, WM_AIMP_PROPERTY, AIMP_RA_PROPERTY_PLAYER_STATE | AIMP_RA_PROPVALUE_GET, 0);
+	}
+	return STOPPED;
+}
+
+void AIMPTuneController::check()
+{
+	HWND aimp = findAimp();
+	if (getAimpStatus(aimp) == PLAYING) {
+		sendTune(getTune());
+	}
+	else {
+		clearTune();
+	}
+	PollingTuneController::check();
+}
+
+Tune AIMPTuneController::currentTune() const
+{
+	return _currentTune;
+}
+
+Tune AIMPTuneController::getTune() const
+{
+	QString title = "";
+	QString album = "";
+	QString artist = "";
+	QString url="";
+	HANDLE aFile=OpenFileMapping(FILE_MAP_READ, TRUE, AIMP_REMOTE_CLASS);
+	TAIMPFileInfo *aInfo=(TAIMPFileInfo *)MapViewOfFile(aFile, FILE_MAP_READ, 0, 0, AIMPRemoteAccessMapFileSize);
+	if (aInfo != NULL) {
+		wchar_t *str = (wchar_t *)((DWORD)aInfo+ aInfo->StructSize);
+		album = QString::fromWCharArray(str, aInfo->AlbumLength);
+		str += aInfo->AlbumLength;
+		artist = QString::fromWCharArray(str, aInfo->ArtistLength);
+		str += aInfo->ArtistLength + aInfo->DateLength;
+		url = QString::fromWCharArray(str, aInfo->FileNameLength);
+		str += aInfo->FileNameLength + aInfo->GenreLength;
+		title = QString::fromWCharArray(str, aInfo->TitleLength);
+	}
+	UnmapViewOfFile(aInfo);
+	CloseHandle(aFile);
+	Tune tune = Tune();
+	if (!title.isEmpty()) {
+		tune.setName(title);
+	}
+	if (!artist.isEmpty()) {
+		tune.setArtist(artist);
+	}
+	if (!album.isEmpty()) {
+		tune.setAlbum(album);
+	}
+	if (!url.isEmpty()) {
+		tune.setURL(url);
+	}
+	return tune;
+}
+
+void AIMPTuneController::sendTune(const Tune &tune)
+{
+	if (tune != _currentTune && !tune.isNull()) {
+		_currentTune = tune;
+		_tuneSent = true;
+	}
+}
+
+void AIMPTuneController::clearTune()
+{
+	if (_tuneSent) {
+		_currentTune = Tune();
+		_tuneSent = false;
+	}
+}
--- git.orig/src/tools/tunecontroller/aimptunecontroller.h
+++ git/src/tools/tunecontroller/aimptunecontroller.h
@@ -0,0 +1,51 @@
+/*
+ * aimptunecontroller.h
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef AIMPTUNECONTROLLER_H
+#define AIMPTUNECONTROLLER_H
+
+#include "pollingtunecontroller.h"
+#include "tune.h"
+#include "windows.h"
+
+class AIMPTuneController : public PollingTuneController
+{
+	Q_OBJECT
+
+public:
+	AIMPTuneController();
+	Tune currentTune() const;
+
+protected slots:
+	void check();
+
+private:
+	Tune getTune() const;
+	HWND findAimp() const;
+	int getAimpStatus(const HWND &aimp) const;
+	void sendTune(const Tune &tune);
+	void clearTune();
+
+private:
+	Tune _currentTune;
+	bool _tuneSent;
+};
+
+#endif
--- git.orig/src/tools/tunecontroller/plugins/aimp/aimpplugin.cpp
+++ git/src/tools/tunecontroller/plugins/aimp/aimpplugin.cpp
@@ -0,0 +1,56 @@
+/*
+ * aimpplugin.cpp
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef QT_STATICPLUGIN
+#define QT_STATICPLUGIN
+#endif
+
+#include <QtCore>
+#include <QObject>
+#include <QString>
+
+#include "aimptunecontroller.h"
+#include "tunecontrollerplugin.h"
+
+class AIMPPlugin : public QObject, public TuneControllerPlugin
+{
+
+	Q_OBJECT
+
+	Q_INTERFACES(TuneControllerPlugin)
+
+public:
+	virtual QString name();
+	virtual TuneController* createController();
+};
+
+Q_EXPORT_PLUGIN2(aimpplugin, AIMPPlugin);
+
+QString AIMPPlugin::name()
+{
+	return "AIMP3";
+}
+
+TuneController* AIMPPlugin::createController()
+{
+	return new AIMPTuneController();
+}
+
+#include "aimpplugin.moc"
--- git.orig/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKCommon.h
+++ git/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKCommon.h
@@ -0,0 +1,50 @@
+/* ******************************************** */
+/*                                              */
+/*                AIMP Plugins API              */
+/*             v3.00.960 (01.12.2011)           */
+/*                Common Objects                */
+/*                                              */
+/*              (c) Artem Izmaylov              */
+/*                 www.aimp.ru                  */
+/*             Mail: artem@aimp.ru              */
+/*              ICQ: 345-908-513                */
+/*                                              */
+/* ******************************************** */
+
+#ifndef AIMPSDKCommonH
+#define AIMPSDKCommonH
+
+#include <windows.h>
+#include <unknwn.h>
+
+#pragma pack(push, 1)
+struct TAIMPFileInfo
+{
+	DWORD StructSize;
+	//
+	BOOL  Active;
+	DWORD BitRate;
+	DWORD Channels;
+	DWORD Duration;
+	INT64 FileSize;
+	DWORD Rating;
+	DWORD SampleRate;
+	DWORD TrackNumber;
+	//
+	DWORD AlbumLength;
+	DWORD ArtistLength;
+	DWORD DateLength;
+	DWORD FileNameLength;
+	DWORD GenreLength;
+	DWORD TitleLength;
+	//
+	PWCHAR Album;
+	PWCHAR Artist;
+	PWCHAR Date;
+	PWCHAR FileName;
+	PWCHAR Genre;
+	PWCHAR Title;
+};
+#pragma pack(pop)
+
+#endif
\ В конце файла нет новой строки
--- git.orig/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKRemote.h
+++ git/src/tools/tunecontroller/plugins/aimp/third-party/AIMPSDKRemote.h
@@ -0,0 +1,228 @@
+/* ******************************************** */
+/*                                              */
+/*                AIMP Plugins API              */
+/*             v3.00.960 (01.12.2011)           */
+/*                 Remote Access                */
+/*                                              */
+/*              (c) Artem Izmaylov              */
+/*                 www.aimp.ru                  */
+/*             Mail: artem@aimp.ru              */
+/*              ICQ: 345-908-513                */
+/*                                              */
+/* ******************************************** */
+
+#ifndef AIMPSDKRemoteH
+#define AIMPSDKRemoteH
+
+#include <windows.h>
+
+const char AIMPRemoteAccessClass[] = "AIMP2_RemoteInfo";
+const int  AIMPRemoteAccessMapFileSize = 2048;
+
+// Messages, which you can send to window with "AIMPRemoteAccessClass" class
+// You can receive Window Handle via FindWindow function (see MSDN for details)
+const int WM_AIMP_COMMAND  = WM_USER + 0x75;
+const int WM_AIMP_NOTIFY   = WM_USER + 0x76;
+const int WM_AIMP_PROPERTY = WM_USER + 0x77;
+
+// See AIMP_RA_CMD_GET_COVER_ART command
+const int WM_AIMP_COPYDATA_COVER_ID = 0x41495043;
+
+//==============================================================================
+// + How to:
+//     GET:  SendMessage(Handle, WM_AIMP_PROPERTY, PropertyID | AIMP_RA_PROPVALUE_GET, 0);
+//     SET:  SendMessage(Handle, WM_AIMP_PROPERTY, PropertyID | AIMP_RA_PROPVALUE_SET, NewValue);
+//
+//     Receive Change Notification:
+//       1) You should register notification hook using AIMP_RA_CMD_REGISTER_NOTIFY command
+//       2) When property will change you receive WM_AIMP_NOTIFY message with following params:
+//          WParam: AIMP_RA_NOTIFY_PROPERTY (Notification ID)
+//          LParam: Property ID
+//
+// Properties ID:
+//==============================================================================
+
+const int AIMP_RA_PROPVALUE_GET = 0;
+const int AIMP_RA_PROPVALUE_SET = 1;
+
+const int AIMP_RA_PROPERTY_MASK = 0xFFFFFFF0;
+
+// !! ReadOnly
+// Returns player version:
+// HiWord: Version ID (for example: 301 -> v3.01)
+// LoWord: Build Number
+const int AIMP_RA_PROPERTY_VERSION = 0x10;
+
+// GET: Returns current position of now playing track (in msec)
+// SET: LParam: position (in msec)
+const int AIMP_RA_PROPERTY_PLAYER_POSITION = 0x20;
+
+// !! ReadOnly
+// Returns duration of now playing track (in msec)
+const int AIMP_RA_PROPERTY_PLAYER_DURATION = 0x30;
+
+// !! ReadOnly
+// Returns current player state
+//  0 = Stopped
+//  1 = Paused
+//  2 = Playing
+const int AIMP_RA_PROPERTY_PLAYER_STATE = 0x40;
+
+// GET: Return current volume [0..100] (%)
+// SET: LParam: volume [0..100] (%)
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_VOLUME = 0x50;
+
+// GET: Return current mute state [0..1]
+// SET: LParam: Mute state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_MUTE = 0x60;
+
+// GET: Return track repeat state [0..1]
+// SET: LParam: Track Repeat state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_TRACK_REPEAT = 0x70;
+
+// GET: Return shuffle state [0..1]
+// SET: LParam: shuffle state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_TRACK_SHUFFLE = 0x80;
+
+// GET: Return radio capture state [0..1]
+// SET: LParam: radio capture state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_RADIOCAP = 0x90;
+
+//==============================================================================
+// Commands ID for WM_AIMP_COMMAND message: (Command ID must be defined in WParam)
+//==============================================================================
+
+const int AIMP_RA_CMD_BASE = 10;
+
+// LParam: Window Handle, which will receive WM_AIMP_NOTIFY message from AIMP
+// See description for WM_AIMP_NOTIFY message for details
+const int AIMP_RA_CMD_REGISTER_NOTIFY = AIMP_RA_CMD_BASE + 1;
+
+// LParam: Window Handle
+const int AIMP_RA_CMD_UNREGISTER_NOTIFY = AIMP_RA_CMD_BASE + 2;
+
+// Start / Resume playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PLAY = AIMP_RA_CMD_BASE + 3;
+
+// Pause / Start playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PLAYPAUSE = AIMP_RA_CMD_BASE + 4;
+
+// Pause / Resume playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PAUSE = AIMP_RA_CMD_BASE + 5;
+
+// Stop playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_STOP = AIMP_RA_CMD_BASE + 6;
+
+// Next Track
+const int AIMP_RA_CMD_NEXT = AIMP_RA_CMD_BASE + 7;
+
+// Previous Track
+const int AIMP_RA_CMD_PREV = AIMP_RA_CMD_BASE + 8;
+
+// Next Visualization
+const int AIMP_RA_CMD_VISUAL_NEXT = AIMP_RA_CMD_BASE + 9;
+
+// Previous Visualization
+const int AIMP_RA_CMD_VISUAL_PREV = AIMP_RA_CMD_BASE + 10;
+
+// Close the program
+const int AIMP_RA_CMD_QUIT = AIMP_RA_CMD_BASE + 11;
+
+// Execute "Add files" dialog
+const int AIMP_RA_CMD_ADD_FILES = AIMP_RA_CMD_BASE + 12;
+
+// Execute "Add folders" dialog
+const int AIMP_RA_CMD_ADD_FOLDERS = AIMP_RA_CMD_BASE + 13;
+
+// Execute "Add Playlists" dialog
+const int AIMP_RA_CMD_ADD_PLAYLISTS = AIMP_RA_CMD_BASE + 14;
+
+// Execute "Add URL" dialog
+const int AIMP_RA_CMD_ADD_URL = AIMP_RA_CMD_BASE + 15;
+
+// Execute "Open Files" dialog
+const int AIMP_RA_CMD_OPEN_FILES = AIMP_RA_CMD_BASE + 16;
+
+// Execute "Open Folders" dialog
+const int AIMP_RA_CMD_OPEN_FOLDERS = AIMP_RA_CMD_BASE + 17;
+
+// Execute "Open Playlist" dialog
+const int AIMP_RA_CMD_OPEN_PLAYLISTS = AIMP_RA_CMD_BASE + 18;
+
+// CoverArt Request
+//   LParam: Window Handle, which will process WM_COPYDATA message from AIMP with CoverArt data
+//   Result: 0, if player doesn't play anything or cover art unavailable
+//
+// How to use it:
+//
+//  1. You should send request to AIMP
+//
+//    SendMessage(AIMPWndHandle, WM_AIMP_COMMAND, AIMP_RA_CMD_GET_COVER_ART, Form1.Handle);
+//
+//  2. And AIMP will answer to you via WM_COPYDATA message:
+//
+//    CopyDataStruct.dwData: SyncWord - must be WM_AIMP_COPYDATA_COVER_ID
+//    CopyDataStruct.lpData: Pointer to Image Data (in PNG format)
+//    CopyDataStruct.cbData: Size Of Image Data (in bytes)
+//
+//    procedure TForm1.WMCopyData(var Message: TWMCopyData);
+//    var
+//      AImage: TPngImage;
+//      AStream: TMemoryStream;
+//    begin
+//      if Message.CopyDataStruct^.dwData = WM_AIMP_COPYDATA_COVER_ID then
+//      begin
+//        AStream := TMemoryStream.Create;
+//        try
+//          AStream.WriteBuffer(Message.CopyDataStruct^.lpData^, Message.CopyDataStruct^.cbData);
+//          AStream.Position := 0;
+//          AImage := TPngImage.Create;
+//          try
+//            AImage.LoadFromStream(AStream);
+//            Image1.Picture.Graphic := AImage;
+//          except
+//            Image1.Picture.Graphic := nil;
+//            AImage.Free;
+//          end;
+//        finally
+//          AStream.Free;
+//        end;
+//      end;
+//    end;
+//
+const int AIMP_RA_CMD_GET_COVER_ART = AIMP_RA_CMD_BASE + 19;
+
+//==============================================================================
+// Notifications ID for WM_AIMP_NOTIFY message: (Notification ID in WParam)
+//==============================================================================
+
+const int AIMP_RA_NOTIFY_BASE = 0;
+
+// Called, if information about now playing file has been changed
+// You can read the information in the following manner:
+//
+// var
+//   AInfo: PAIMPFileInfo;
+// begin
+//   AFile := OpenFileMapping(FILE_MAP_READ, True, AIMPRemoteAccessClass);
+//   AInfo := MapViewOfFile(AFile, FILE_MAP_READ, 0, 0, AIMPRemoteAccessMapFileSize);
+//   ...
+const int AIMP_RA_NOTIFY_TRACK_INFO = AIMP_RA_NOTIFY_BASE + 1;
+
+// Called, when audio stream starts playing or when an Internet radio station changes the track
+const int AIMP_RA_NOTIFY_TRACK_START = AIMP_RA_NOTIFY_BASE + 2;
+
+// Called, when property has been changed
+// LParam: Property ID
+const int AIMP_RA_NOTIFY_PROPERTY = AIMP_RA_NOTIFY_BASE + 3; 
+
+#endif
\ В конце файла нет новой строки
--- git.orig/src/tools/tunecontroller/tunecontrollermanager.cpp
+++ git/src/tools/tunecontroller/tunecontrollermanager.cpp
@@ -164,6 +164,10 @@ Q_IMPORT_PLUGIN(itunesplugin)
 Q_IMPORT_PLUGIN(winampplugin)
 #endif
 
+#ifdef TC_AIMP
+Q_IMPORT_PLUGIN(aimpplugin)
+#endif
+
 #ifdef TC_PSIFILE
 Q_IMPORT_PLUGIN(psifileplugin)
 #endif
--- git.orig/src/tools/tunecontroller/tunecontroller.pri
+++ git/src/tools/tunecontroller/tunecontroller.pri
@@ -78,3 +78,17 @@ tc_mpris {
 		$$PWD/mpristunecontroller.cpp \
 		$$MPRIS_PLUGIN_PATH/mprisplugin.cpp
 }
+
+#AIMP
+tc_aimp {
+	DEFINES += TC_AIMP
+	AIMP_PLUGIN_PATH = $$PWD/plugins/aimp
+	INCLUDEPATH += $$AIMP_PLUGIN_PATH
+
+	HEADERS += \
+		$$PWD/aimptunecontroller.h
+
+	SOURCES += \
+		$$PWD/aimptunecontroller.cpp \
+		$$AIMP_PLUGIN_PATH/aimpplugin.cpp
+}
