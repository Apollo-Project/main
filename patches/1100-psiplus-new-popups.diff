--- psi.orig/options/default.xml
+++ psi/options/default.xml
@@ -397,6 +397,7 @@ QLineEdit#le_status_text {
 			</look>
 			<notifications>
 				<alert-style type="QString">animate</alert-style>
+				<type type="int">0</type>
 				<bounce-dock type="QString">forever</bounce-dock>
 				<send-receipts type="bool" >true</send-receipts>
 				<request-receipts type="bool" >true</request-receipts>
@@ -405,6 +406,7 @@ QLineEdit#le_status_text {
 						<chat type="int">5000</chat>
 						<file type="int">5000</file>
 						<message type="int">5000</message>
+						<gc-message type="int">5000</gc-message>
 						<status type="int">2000</status>
 					</delays>
 					<enabled type="bool">false</enabled>
@@ -412,13 +414,20 @@ QLineEdit#le_status_text {
 					<at-left-corner type="bool">false</at-left-corner>
 					<css type="QString"></css>
 					<incoming-chat type="bool">true</incoming-chat>
+					<composing type="bool">true</composing>
 					<incoming-file-transfer type="bool">true</incoming-file-transfer>
 					<incoming-headline type="bool">true</incoming-headline>
 					<incoming-message type="bool">true</incoming-message>
+					<notify-every-muc-message type="bool">false</notify-every-muc-message>
 					<maximum-jid-length type="int">25</maximum-jid-length>
 					<maximum-text-length type="int">300</maximum-text-length>
 					<maximum-status-length type="int">-1</maximum-status-length>
 					<avatar-size type="int">48</avatar-size>
+					<suppress-while-away type="bool">false</suppress-while-away>
+					<suppress-while-dnd type="bool">true</suppress-while-dnd>
+					<dbus>
+						<transient-hint type="bool">false</transient-hint>
+					</dbus>
 					<status>
 						<offline type="bool">true</offline>
 						<online type="bool">true</online>
@@ -630,6 +639,7 @@ QLineEdit#le_status_text {
 			<ignore-non-roster-contacts type="bool">false</ignore-non-roster-contacts>
 			<send-composing-events type="bool">true</send-composing-events>
 			<send-inactivity-events type="bool">false</send-inactivity-events>
+			<dont-send-composing-events type="bool">false</dont-send-composing-events>
 		</messages>
 		<p2p>
 			<bytestreams>
--- psi.orig/options/macosx.xml
+++ psi/options/macosx.xml
@@ -21,6 +21,9 @@
 					<passive-popup type="QString">Lucida Grande,9,-1,5,50,0,0,0,0,0</passive-popup>
 				</font>
 			</look>
+			<notifications>
+				<type type="int">1</type>
+			</notifications>
 		</ui>
 	</options>
 </psi>
--- psi.orig/src/chatdlg.cpp
+++ psi/src/chatdlg.cpp
@@ -961,36 +961,38 @@ void ChatDlg::setChatState(ChatState sta
 		}
 
 		// Build event message
-		Message m(jid());
-		if (sendComposingEvents_) {
-			m.setEventId(eventId_);
-			if (state == XMPP::StateComposing) {
-				m.addEvent(ComposingEvent);
-			}
-			else if (lastChatState_ == XMPP::StateComposing) {
-				m.addEvent(CancelEvent);
+		if( !PsiOptions::instance()->getOption("options.messages.dont-send-composing-events").toBool() ) {
+			Message m(jid());
+			if (sendComposingEvents_) {
+				m.setEventId(eventId_);
+				if (state == XMPP::StateComposing) {
+					m.addEvent(ComposingEvent);
+				}
+				else if (lastChatState_ == XMPP::StateComposing) {
+					m.addEvent(CancelEvent);
+				}
 			}
-		}
-		if (contactChatState_ != XMPP::StateNone) {
-			if (lastChatState_ != XMPP::StateGone) {
-				if ((state == XMPP::StateInactive && lastChatState_ == XMPP::StateComposing) || (state == XMPP::StateComposing && lastChatState_ == XMPP::StateInactive)) {
-					// First go to the paused state
-					Message tm(jid());
-					m.setType("chat");
-					m.setChatState(XMPP::StatePaused);
-					if (account()->isAvailable()) {
-						account()->dj_sendMessage(m, false);
+			if (contactChatState_ != XMPP::StateNone) {
+				if (lastChatState_ != XMPP::StateGone) {
+					if ((state == XMPP::StateInactive && lastChatState_ == XMPP::StateComposing) || (state == XMPP::StateComposing && lastChatState_ == XMPP::StateInactive)) {
+						// First go to the paused state
+						Message tm(jid());
+						m.setType("chat");
+						m.setChatState(XMPP::StatePaused);
+						if (account()->isAvailable()) {
+							account()->dj_sendMessage(m, false);
+						}
 					}
+					m.setChatState(state);
 				}
-				m.setChatState(state);
 			}
-		}
 
-		// Send event message
-		if (m.containsEvents() || m.chatState() != XMPP::StateNone) {
-			m.setType("chat");
-			if (account()->isAvailable()) {
-				account()->dj_sendMessage(m, false);
+			// Send event message
+			if (m.containsEvents() || m.chatState() != XMPP::StateNone) {
+				m.setType("chat");
+				if (account()->isAvailable()) {
+					account()->dj_sendMessage(m, false);
+				}
 			}
 		}
 
--- psi.orig/src/groupchatdlg.cpp
+++ psi/src/groupchatdlg.cpp
@@ -95,6 +95,8 @@
 #include <windows.h>
 #endif
 
+#include "popupmanager.h"
+#include "psievent.h"
 
 #define MCMDMUC		"http://psi-im.org/ids/mcmd#mucmain"
 #define MCMDMUCNICK	"http://psi-im.org/ids/mcmd#mucnick"
@@ -1629,6 +1631,15 @@ void GCMainDlg::message(const Message &_
 	else {
 		if(alert || (PsiOptions::instance()->getOption("options.ui.notifications.sounds.notify-every-muc-message").toBool() && !m.spooled() && !from.isEmpty()) )
 			account()->playSound(PsiAccount::eGroupChat);
+
+		if(alert || (PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.notify-every-muc-message").toBool() && !m.spooled() && !from.isEmpty()) ) {
+			if (!m.spooled() && !isActiveTab() && !m.from().resource().isEmpty()) {
+				XMPP::Jid jid = m.from()/*.withDomain("")*/;
+				MessageEvent *e = new MessageEvent(m, account());
+				account()->psi()->popupManager()->doPopup(account(), PopupManager::AlertGcHighlight, jid, m.from().resource(), 0, (PsiEvent *)e);
+				e->deleteLater();
+			}
+		}
 	}
 
 	if(from.isEmpty())
--- psi.orig/src/options/opt_advanced.cpp
+++ psi/src/options/opt_advanced.cpp
@@ -96,7 +96,9 @@ QWidget *OptionsTabAdvanced::widget()
 		" like system-wide news on MSN, announcements, etc."));
 
 	connect(d->ck_messageevents,SIGNAL(toggled(bool)),d->ck_inactiveevents,SLOT(setEnabled(bool)));
+	connect(d->ck_messageevents,SIGNAL(toggled(bool)),d->ck_sendComposingEvents,SLOT(setEnabled(bool)));
 	d->ck_inactiveevents->setEnabled(d->ck_messageevents->isChecked());
+	d->ck_sendComposingEvents->setEnabled(d->ck_messageevents->isChecked());
 
 	return w;
 }
@@ -110,6 +112,7 @@ void OptionsTabAdvanced::applyOptions()
 
 	PsiOptions::instance()->setOption("options.messages.send-composing-events", d->ck_messageevents->isChecked());
 	PsiOptions::instance()->setOption("options.messages.send-inactivity-events", d->ck_inactiveevents->isChecked());
+	PsiOptions::instance()->setOption("options.messages.dont-send-composing-events", d->ck_sendComposingEvents->isChecked());
 	PsiOptions::instance()->setOption("options.ui.notifications.request-receipts", d->ck_requestReceipts->isChecked());
 	PsiOptions::instance()->setOption("options.ui.notifications.send-receipts", d->ck_sendReceipts->isChecked());
 	PsiOptions::instance()->setOption("options.external-control.adhoc-remote-control.enable", d->ck_rc->isChecked());
@@ -138,6 +141,7 @@ void OptionsTabAdvanced::restoreOptions(
 
 	d->ck_messageevents->setChecked( PsiOptions::instance()->getOption("options.messages.send-composing-events").toBool() );
 	d->ck_inactiveevents->setChecked( PsiOptions::instance()->getOption("options.messages.send-inactivity-events").toBool() );
+	d->ck_sendComposingEvents->setChecked( PsiOptions::instance()->getOption("options.messages.dont-send-composing-events").toBool() );
 	d->ck_requestReceipts->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.request-receipts").toBool() );
 	d->ck_sendReceipts->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.send-receipts").toBool() );
 	d->ck_rc->setChecked( PsiOptions::instance()->getOption("options.external-control.adhoc-remote-control.enable").toBool() );
--- psi.orig/src/options/opt_advanced.ui
+++ psi/src/options/opt_advanced.ui
@@ -34,6 +34,16 @@
     </widget>
    </item>
    <item>
+    <widget class="QCheckBox" name="ck_sendComposingEvents">
+     <property name="whatsThis">
+      <string>Disables the sending of message events such as &quot;Contact is Typing...&quot;</string>
+     </property>
+     <property name="text">
+      <string>Do not send composing events</string>
+     </property>
+    </widget>
+   </item>
+   <item>
     <widget class="QCheckBox" name="ck_requestReceipts" >
      <property name="text" >
       <string>Request receipts</string>
--- psi.orig/src/options/opt_events.cpp
+++ psi/src/options/opt_events.cpp
@@ -23,9 +23,9 @@ public:
 //----------------------------------------------------------------------------
 
 OptionsTabEvents::OptionsTabEvents(QObject *parent)
-: OptionsTab(parent, "events", "", tr("Events"), tr("The events behaviour"), "psi/events")
+	: OptionsTab(parent, "events", "", tr("Events"), tr("The events behaviour"), "psi/events")
+	, w(0)
 {
-	w = 0;
 }
 
 QWidget *OptionsTabEvents::widget()
@@ -105,16 +105,6 @@ void OptionsTabEvents::applyOptions()
 	PsiOptions::instance()->setOption("options.subscriptions.automatically-allow-authorization", d->ck_autoAuth->isChecked());
 	PsiOptions::instance()->setOption("options.ui.notifications.successful-subscription", d->ck_notifyAuth->isChecked());
 	PsiOptions::instance()->setOption("options.ui.notifications.bounce-dock", d->cb_bounce->itemData( d->cb_bounce->currentIndex()));
-
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.enabled", d->ck_popupOn->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.incoming-message", d->ck_popupOnMessage->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.showMessage", d->ck_showPopupMessage->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.incoming-chat", d->ck_popupOnMessage->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.incoming-headline", d->ck_popupOnHeadline->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.incoming-file-transfer", d->ck_popupOnFile->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.status.online", d->ck_popupOnOnline->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.status.offline", d->ck_popupOnOffline->isChecked());
-	PsiOptions::instance()->setOption("options.ui.notifications.passive-popups.status.other-changes", d->ck_popupOnStatus->isChecked());
 }
 
 void OptionsTabEvents::restoreOptions()
@@ -134,12 +124,4 @@ void OptionsTabEvents::restoreOptions()
 	d->ck_autoAuth->setChecked( PsiOptions::instance()->getOption("options.subscriptions.automatically-allow-authorization").toBool() );
 	d->ck_notifyAuth->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.successful-subscription").toBool() );
 	d->cb_bounce->setCurrentIndex( d->cb_bounce->findData(PsiOptions::instance()->getOption("options.ui.notifications.bounce-dock").toString()) );
-	d->ck_popupOn->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.enabled").toBool() );
-	d->ck_popupOnMessage->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-message").toBool() || PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-chat").toBool() );
-	d->ck_showPopupMessage->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.showMessage").toBool());
-	d->ck_popupOnHeadline->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-headline").toBool() );
-	d->ck_popupOnFile->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-file-transfer").toBool() );
-	d->ck_popupOnOnline->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.online").toBool() );
-	d->ck_popupOnOffline->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.offline").toBool() );
-	d->ck_popupOnStatus->setChecked( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.other-changes").toBool() );
 }
--- psi.orig/src/options/opt_events.ui
+++ psi/src/options/opt_events.ui
@@ -6,7 +6,7 @@
     <x>0</x>
     <y>0</y>
     <width>347</width>
-    <height>588</height>
+    <height>335</height>
    </rect>
   </property>
   <property name="windowTitle" >
@@ -192,80 +192,6 @@
      </item>
     </layout>
    </item>
-   <item>
-    <widget class="QCheckBox" name="ck_popupOn" >
-     <property name="text" >
-      <string>Enable popup notifications</string>
-     </property>
-     <property name="checked" >
-      <bool>true</bool>
-     </property>
-    </widget>
-   </item>
-   <item>
-    <widget class="QGroupBox" name="groupBox1" >
-     <property name="title" >
-      <string>Popup notifications</string>
-     </property>
-     <layout class="QVBoxLayout" >
-      <property name="margin" >
-       <number>10</number>
-      </property>
-      <property name="spacing" >
-       <number>6</number>
-      </property>
-      <item>
-       <widget class="QCheckBox" name="ck_popupOnMessage" >
-        <property name="text" >
-         <string>On incoming message event</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="ck_showPopupMessage" >
-        <property name="text" >
-         <string>Show incoming message on popup</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="ck_popupOnHeadline" >
-        <property name="text" >
-         <string>On incoming headline event</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="ck_popupOnFile" >
-        <property name="text" >
-         <string>On incoming file event</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="ck_popupOnOnline" >
-        <property name="text" >
-         <string>When a contact becomes available</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="ck_popupOnOffline" >
-        <property name="text" >
-         <string>When a contact becomes unavailable</string>
-        </property>
-       </widget>
-      </item>
-      <item>
-       <widget class="QCheckBox" name="ck_popupOnStatus" >
-        <property name="text" >
-         <string>When a contact changes status</string>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </widget>
-   </item>
   </layout>
  </widget>
  <layoutdefault spacing="6" margin="11" />
@@ -281,31 +207,6 @@
   <tabstop>ck_notifyAuth</tabstop>
   <tabstop>cb_bounce</tabstop>
   <tabstop>cb_animation</tabstop>
-  <tabstop>ck_popupOn</tabstop>
-  <tabstop>ck_popupOnMessage</tabstop>
-  <tabstop>ck_popupOnHeadline</tabstop>
-  <tabstop>ck_popupOnFile</tabstop>
-  <tabstop>ck_popupOnOnline</tabstop>
-  <tabstop>ck_popupOnOffline</tabstop>
-  <tabstop>ck_popupOnStatus</tabstop>
  </tabstops>
  <resources/>
- <connections>
-  <connection>
-   <sender>ck_popupOn</sender>
-   <signal>toggled(bool)</signal>
-   <receiver>groupBox1</receiver>
-   <slot>setEnabled(bool)</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>158</x>
-     <y>384</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>158</x>
-     <y>425</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
 </ui>
--- psi.orig/src/options/optionsdlg.cpp
+++ psi/src/options/optionsdlg.cpp
@@ -44,6 +44,7 @@
 #include "opt_appearance.h"
 #include "opt_chat.h"
 #include "opt_events.h"
+#include "opt_popups.h"
 #include "opt_status.h"
 #include "opt_iconset.h"
 #include "opt_groupchat.h"
@@ -277,6 +278,7 @@ void OptionsDlg::Private::createTabs()
 	tabs.append( new OptionsTabRoster(this) );
 	tabs.append( new OptionsTabChat(this) );
 	tabs.append( new OptionsTabEvents(this) );
+	tabs.append( new OptionsTabPopups(this) );
 	tabs.append( new OptionsTabStatus(this) );
 	tabs.append( new OptionsTabAppearance(this) );
 	//tabs.append( new OptionsTabIconsetSystem(this) );
--- psi.orig/src/options/options.pri
+++ psi/src/options/options.pri
@@ -15,6 +15,7 @@ HEADERS += \
 	$$PWD/opt_roster.h \
 	$$PWD/opt_chat.h \
 	$$PWD/opt_events.h \
+	$$PWD/opt_popups.h \
 	$$PWD/opt_status.h \
 	$$PWD/opt_statusgeneral.h \
 	$$PWD/opt_statusauto.h \
@@ -35,6 +36,7 @@ SOURCES += \
 	$$PWD/opt_roster.cpp \
 	$$PWD/opt_chat.cpp \
 	$$PWD/opt_events.cpp \
+	$$PWD/opt_popups.cpp \
 	$$PWD/opt_status.cpp \
 	$$PWD/opt_statusgeneral.cpp \
 	$$PWD/opt_statusauto.cpp \
@@ -55,6 +57,7 @@ FORMS += \
 	$$PWD/opt_roster.ui \
 	$$PWD/opt_chat.ui \
 	$$PWD/opt_events.ui \
+	$$PWD/opt_popups.ui \
 	$$PWD/opt_statusgeneral.ui \
 	$$PWD/opt_statusauto.ui \
 	$$PWD/opt_appearance.ui \
--- psi.orig/src/options/opt_popups.cpp
+++ psi/src/options/opt_popups.cpp
@@ -0,0 +1,167 @@
+/*
+ * opt_popups.cpp
+ * Copyright (C) 2011  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+//#include <QHBoxLayout>
+#include <QRadioButton>
+
+#include "opt_popups.h"
+#include "ui_opt_popups.h"
+#include "psioptions.h"
+#include "psicon.h"
+#include "popupmanager.h"
+
+class OptPopupsUI : public QWidget, public Ui::OptPopups
+{
+public:
+	OptPopupsUI() : QWidget() { setupUi(this); }
+};
+
+OptionsTabPopups::OptionsTabPopups(QObject *parent)
+	: OptionsTab(parent, "popups", "", tr("Popups"), tr("The popups behaviour"), "psi/tip")
+	, w(0)
+	, popup_(0)
+{
+}
+
+QWidget *OptionsTabPopups::widget()
+{
+	if ( w )
+		return 0;
+
+	w = new OptPopupsUI();
+	return w;
+}
+
+void OptionsTabPopups::applyOptions()
+{
+	if ( !w )
+		return;
+
+	OptPopupsUI *d = (OptPopupsUI *)w;
+
+	PsiOptions *o = PsiOptions::instance();
+
+	o->setOption("options.ui.notifications.passive-popups.enabled", d->ck_popupOn->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.incoming-message", d->ck_popupOnMessage->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.showMessage", d->ck_showPopupMessage->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.incoming-chat", d->ck_popupOnMessage->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.incoming-headline", d->ck_popupOnHeadline->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.incoming-file-transfer", d->ck_popupOnFile->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.status.online", d->ck_popupOnOnline->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.status.offline", d->ck_popupOnOffline->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.status.other-changes", d->ck_popupOnStatus->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.composing", d->ck_popupComposing->isChecked());
+	o->setOption("options.ui.notifications.passive-popups.avatar-size", d->sb_avatar->value());
+
+	o->setOption("options.ui.notifications.passive-popups.maximum-jid-length", QVariant(d->sb_jid->value()));
+	o->setOption("options.ui.notifications.passive-popups.maximum-status-length", QVariant(d->sb_status->value()));
+	o->setOption("options.ui.notifications.passive-popups.maximum-text-length", QVariant(d->sb_text->value()));
+	o->setOption("options.ui.notifications.passive-popups.top-to-bottom",QVariant(d->ck_topToBottom->isChecked()));
+	o->setOption("options.ui.notifications.passive-popups.at-left-corner",QVariant(d->ck_atLeft->isChecked()));
+	o->setOption("options.ui.notifications.passive-popups.notify-every-muc-message",QVariant(d->ck_everyMucMessage->isChecked()));
+
+	foreach(QObject* obj, d->sa_durations->widget()->children()) {
+		QSpinBox *sb = dynamic_cast<QSpinBox*>(obj);
+		if(sb) {
+			const QString oName = sb->property("name").toString();
+			const QString oPath = sb->property("path").toString();
+			const int value = sb->value();
+			popup_->setValue(oName, value);
+			if(!oPath.isEmpty()) {
+				PsiOptions::instance()->setOption(oPath, value*1000);
+			}
+		}
+	}
+
+	foreach(QObject* obj, d->gb_type->children()) {
+		QRadioButton *rb = dynamic_cast<QRadioButton*>(obj);
+		if(rb && rb->isChecked()) {
+			o->setOption("options.ui.notifications.type", rb->property("type"));
+			break;
+		}
+	}
+}
+
+void OptionsTabPopups::restoreOptions()
+{
+	if ( !w )
+		return;
+
+	OptPopupsUI *d = (OptPopupsUI *)w;
+
+	PsiOptions *o = PsiOptions::instance();
+
+	d->ck_popupOn->setChecked( o->getOption("options.ui.notifications.passive-popups.enabled").toBool() );
+	d->ck_popupOnMessage->setChecked( o->getOption("options.ui.notifications.passive-popups.incoming-message").toBool() || o->getOption("options.ui.notifications.passive-popups.incoming-chat").toBool() );
+	d->ck_showPopupMessage->setChecked( o->getOption("options.ui.notifications.passive-popups.showMessage").toBool());
+	d->ck_popupOnHeadline->setChecked( o->getOption("options.ui.notifications.passive-popups.incoming-headline").toBool() );
+	d->ck_popupOnFile->setChecked( o->getOption("options.ui.notifications.passive-popups.incoming-file-transfer").toBool() );
+	d->ck_popupOnOnline->setChecked( o->getOption("options.ui.notifications.passive-popups.status.online").toBool() );
+	d->ck_popupOnOffline->setChecked( o->getOption("options.ui.notifications.passive-popups.status.offline").toBool() );
+	d->ck_popupOnStatus->setChecked( o->getOption("options.ui.notifications.passive-popups.status.other-changes").toBool() );
+	d->ck_popupComposing->setChecked( o->getOption("options.ui.notifications.passive-popups.composing").toBool() );
+	d->sb_avatar->setValue( o->getOption("options.ui.notifications.passive-popups.avatar-size").toInt() );
+
+	d->sb_jid->setValue(o->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt());
+	d->sb_status->setValue(o->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt());
+	d->sb_text->setValue(o->getOption("options.ui.notifications.passive-popups.maximum-text-length").toInt());
+	d->ck_topToBottom->setChecked(o->getOption("options.ui.notifications.passive-popups.top-to-bottom").toBool());
+	d->ck_atLeft->setChecked(o->getOption("options.ui.notifications.passive-popups.at-left-corner").toBool());
+	d->ck_everyMucMessage->setChecked(o->getOption("options.ui.notifications.passive-popups.notify-every-muc-message").toBool());
+
+	QWidget *areaWidget = new QWidget;
+	QVBoxLayout *vBox = new QVBoxLayout(areaWidget);
+	foreach(const QString& option, popup_->optionsNamesList()) {
+		QHBoxLayout *l = new QHBoxLayout;
+		l->addWidget(new QLabel(option));
+		l->addStretch();
+		QSpinBox *sb = new QSpinBox();
+		sb->setMinimum(-1);
+		sb->setValue(popup_->value(option));
+		sb->setProperty("path", popup_->optionPath(option));
+		sb->setProperty("name", option);
+		l->addWidget(sb);
+		vBox->addLayout(l);
+	}
+	d->sa_durations->setWidget(areaWidget);
+
+	delete d->gb_type->layout();
+	qDeleteAll(d->gb_type->children());
+	QHBoxLayout *l = new QHBoxLayout(d->gb_type);
+
+	foreach(PopupManager::NotificationsType type_, PopupManager::availableTypes()) {
+		QRadioButton* rb = new QRadioButton(PopupManager::nameByType(type_));
+		rb->setProperty("type", type_);
+		d->gb_type->layout()->addWidget(rb);
+		l->addWidget(rb);
+		if(PopupManager::currentType() == type_)
+			rb->setChecked(true);
+	}
+
+	if(l->count() == 1)
+		d->gb_type->setVisible(false);
+
+	emit connectDataChanged(w);
+}
+
+void OptionsTabPopups::setData(PsiCon *psi, QWidget *)
+{
+	popup_ = psi->popupManager();
+}
--- psi.orig/src/options/opt_popups.h
+++ psi/src/options/opt_popups.h
@@ -0,0 +1,49 @@
+/*
+ * opt_popups.h
+ * Copyright (C) 2011  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef OPT_POPUPS_H
+#define OPT_POPUPS_H
+
+#include "optionstab.h"
+
+class PsiCon;
+class PopupManager;
+
+class OptionsTabPopups : public OptionsTab
+{
+	Q_OBJECT
+public:
+	OptionsTabPopups(QObject *parent);
+
+	QWidget *widget();
+	void applyOptions();
+	void restoreOptions();
+
+	virtual bool stretchable() const { return true; }
+
+public slots:
+	virtual void setData(PsiCon *psi, QWidget *);
+
+private:
+	QWidget *w;
+	PopupManager* popup_;
+};
+
+#endif
--- psi.orig/src/options/opt_popups.ui
+++ psi/src/options/opt_popups.ui
@@ -0,0 +1,421 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>OptPopups</class>
+ <widget class="QWidget" name="OptPopups">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>608</width>
+    <height>520</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>OptPopupsUI</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout_4">
+   <item>
+    <widget class="QCheckBox" name="ck_popupOn">
+     <property name="text">
+      <string>Enable popup notifications</string>
+     </property>
+     <property name="checked">
+      <bool>true</bool>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QGroupBox" name="gb_type">
+     <property name="title">
+      <string>Notifications type</string>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <widget class="QTabWidget" name="tabWidget">
+     <property name="autoFillBackground">
+      <bool>false</bool>
+     </property>
+     <property name="currentIndex">
+      <number>0</number>
+     </property>
+     <widget class="QWidget" name="tab">
+      <attribute name="title">
+       <string>General</string>
+      </attribute>
+      <layout class="QVBoxLayout" name="verticalLayout_3">
+       <item>
+        <widget class="QGroupBox" name="groupBox1">
+         <property name="title">
+          <string>Popup notifications</string>
+         </property>
+         <layout class="QVBoxLayout" name="verticalLayout_2">
+          <item>
+           <widget class="QCheckBox" name="ck_popupOnMessage">
+            <property name="text">
+             <string>On incoming message event</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_showPopupMessage">
+            <property name="text">
+             <string>Show incoming message on popup</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_popupOnHeadline">
+            <property name="text">
+             <string>On incoming headline event</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_popupOnFile">
+            <property name="text">
+             <string>On incoming file event</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_popupComposing">
+            <property name="text">
+             <string>When a contact begins typing</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_popupOnOnline">
+            <property name="text">
+             <string>When a contact becomes available</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_popupOnOffline">
+            <property name="text">
+             <string>When a contact becomes unavailable</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_popupOnStatus">
+            <property name="text">
+             <string>When a contact changes status</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="ck_everyMucMessage">
+            <property name="text">
+             <string>Enable popup notifications for every muc message</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item>
+        <layout class="QGridLayout" name="gridLayout">
+         <item row="0" column="0">
+          <widget class="QGroupBox" name="groupBox">
+           <property name="title">
+            <string>Limitations</string>
+           </property>
+           <layout class="QGridLayout" name="_3">
+            <item row="0" column="0">
+             <widget class="QLabel" name="label">
+              <property name="text">
+               <string>Maximum JID length:</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="1">
+             <widget class="QSpinBox" name="sb_jid">
+              <property name="sizePolicy">
+               <sizepolicy hsizetype="Maximum" vsizetype="Fixed">
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="minimum">
+               <number>-1</number>
+              </property>
+              <property name="maximum">
+               <number>999</number>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="0">
+             <widget class="QLabel" name="label_2">
+              <property name="text">
+               <string>Maximum text length:</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="1">
+             <widget class="QSpinBox" name="sb_text">
+              <property name="sizePolicy">
+               <sizepolicy hsizetype="Maximum" vsizetype="Fixed">
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="minimum">
+               <number>-1</number>
+              </property>
+              <property name="maximum">
+               <number>999</number>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="0">
+             <widget class="QLabel" name="label_3">
+              <property name="text">
+               <string>Maximum status length:</string>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+              </property>
+             </widget>
+            </item>
+            <item row="2" column="1">
+             <widget class="QSpinBox" name="sb_status">
+              <property name="sizePolicy">
+               <sizepolicy hsizetype="Maximum" vsizetype="Fixed">
+                <horstretch>0</horstretch>
+                <verstretch>0</verstretch>
+               </sizepolicy>
+              </property>
+              <property name="minimum">
+               <number>-1</number>
+              </property>
+              <property name="maximum">
+               <number>999</number>
+              </property>
+             </widget>
+            </item>
+           </layout>
+          </widget>
+         </item>
+         <item row="0" column="1">
+          <widget class="QGroupBox" name="groupBox2">
+           <property name="title">
+            <string>Popup location</string>
+           </property>
+           <layout class="QVBoxLayout" name="_2" stretch="0,0,0">
+            <item>
+             <widget class="QCheckBox" name="ck_topToBottom">
+              <property name="text">
+               <string>Show popups from top to bottom</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <widget class="QCheckBox" name="ck_atLeft">
+              <property name="text">
+               <string>Place popups at left</string>
+              </property>
+             </widget>
+            </item>
+            <item>
+             <spacer name="verticalSpacer_2">
+              <property name="orientation">
+               <enum>Qt::Vertical</enum>
+              </property>
+              <property name="sizeHint" stdset="0">
+               <size>
+                <width>20</width>
+                <height>40</height>
+               </size>
+              </property>
+             </spacer>
+            </item>
+           </layout>
+          </widget>
+         </item>
+         <item row="0" column="2">
+          <spacer name="horizontalSpacer">
+           <property name="orientation">
+            <enum>Qt::Horizontal</enum>
+           </property>
+           <property name="sizeHint" stdset="0">
+            <size>
+             <width>40</width>
+             <height>20</height>
+            </size>
+           </property>
+          </spacer>
+         </item>
+        </layout>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="tab_2">
+      <attribute name="title">
+       <string>Misc</string>
+      </attribute>
+      <layout class="QVBoxLayout" name="verticalLayout">
+       <item>
+        <layout class="QHBoxLayout" name="horizontalLayout_2">
+         <item>
+          <widget class="QLabel" name="label_4">
+           <property name="text">
+            <string>Avatar size:</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QSpinBox" name="sb_avatar"/>
+         </item>
+         <item>
+          <spacer name="horizontalSpacer_3">
+           <property name="orientation">
+            <enum>Qt::Horizontal</enum>
+           </property>
+           <property name="sizeHint" stdset="0">
+            <size>
+             <width>40</width>
+             <height>20</height>
+            </size>
+           </property>
+          </spacer>
+         </item>
+        </layout>
+       </item>
+       <item>
+        <layout class="QHBoxLayout" name="horizontalLayout">
+         <item>
+          <widget class="QGroupBox" name="gb_durations">
+           <property name="title">
+            <string>Durations, sec.</string>
+           </property>
+           <layout class="QVBoxLayout" name="verticalLayout_5">
+            <item>
+             <widget class="QScrollArea" name="sa_durations">
+              <property name="autoFillBackground">
+               <bool>false</bool>
+              </property>
+              <property name="frameShape">
+               <enum>QFrame::NoFrame</enum>
+              </property>
+              <property name="frameShadow">
+               <enum>QFrame::Sunken</enum>
+              </property>
+              <property name="lineWidth">
+               <number>0</number>
+              </property>
+              <property name="horizontalScrollBarPolicy">
+               <enum>Qt::ScrollBarAlwaysOff</enum>
+              </property>
+              <property name="widgetResizable">
+               <bool>false</bool>
+              </property>
+              <property name="alignment">
+               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+              </property>
+              <widget class="QWidget" name="scrollAreaWidgetContents">
+               <property name="geometry">
+                <rect>
+                 <x>0</x>
+                 <y>0</y>
+                 <width>538</width>
+                 <height>81</height>
+                </rect>
+               </property>
+               <property name="autoFillBackground">
+                <bool>false</bool>
+               </property>
+              </widget>
+             </widget>
+            </item>
+           </layout>
+          </widget>
+         </item>
+         <item>
+          <spacer name="horizontalSpacer_2">
+           <property name="orientation">
+            <enum>Qt::Horizontal</enum>
+           </property>
+           <property name="sizeHint" stdset="0">
+            <size>
+             <width>0</width>
+             <height>0</height>
+            </size>
+           </property>
+          </spacer>
+         </item>
+        </layout>
+       </item>
+       <item>
+        <spacer name="verticalSpacer">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>10</width>
+           <height>0</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <layoutdefault spacing="6" margin="11"/>
+ <tabstops>
+  <tabstop>ck_popupOn</tabstop>
+  <tabstop>ck_popupOnMessage</tabstop>
+  <tabstop>ck_popupOnHeadline</tabstop>
+  <tabstop>ck_popupOnFile</tabstop>
+  <tabstop>ck_popupOnOnline</tabstop>
+  <tabstop>ck_popupOnOffline</tabstop>
+  <tabstop>ck_popupOnStatus</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>ck_popupOn</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>tabWidget</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>303</x>
+     <y>19</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>303</x>
+     <y>273</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>ck_popupOn</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>gb_type</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>303</x>
+     <y>19</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>303</x>
+     <y>50</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
--- psi.orig/src/popupmanager.cpp
+++ psi/src/popupmanager.cpp
@@ -0,0 +1,316 @@
+/*
+ * popupmanager.cpp
+ * Copyright (C) 2011-2012  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "popupmanager.h"
+
+#include "psioptions.h"
+#include "psiaccount.h"
+#include "psicon.h"
+#include "psipopup.h"
+
+#include "xmpp/jid/jid.h"
+
+#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
+#include "psigrowlnotifier.h"
+#endif
+
+#ifdef USE_DBUS
+#include "psidbusnotifier.h"
+#endif
+
+
+static const int defaultTimeout = 5;
+
+struct OptionValue
+{
+	OptionValue(const QString& name, const QString& path, int value, int _id = 0)
+		: optionName(name)
+		, optionPath(path)
+		, optionValue(value)
+		, id(_id)
+	{
+	}
+
+	QString optionName;
+	QString optionPath;
+	int optionValue; //value in secconds
+	int id;
+
+	bool operator==(const OptionValue& other)
+	{
+		return optionName == other.optionName;
+	}
+};
+
+class PopupManager::Private
+{
+
+public:
+	Private()
+		: psi_(0)
+		, lastCustomType_(PopupManager::AlertCustom)
+	{
+	}
+
+	PsiCon* psi_;
+	int lastCustomType_;
+	QList<OptionValue> options_;
+};
+
+PopupManager::PopupManager(PsiCon *psi)
+{
+	d = new Private;
+	d->psi_ = psi;
+
+	QList<OptionValue> initList;
+	initList << OptionValue(QObject::tr("Status"), "options.ui.notifications.passive-popups.delays.status",
+			PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.status").toInt()/1000, AlertOnline)
+	<< OptionValue(QObject::tr("Headline"),  "options.ui.notifications.passive-popups.delays.message",
+			PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.message").toInt()/1000, AlertHeadline)
+	<< OptionValue(QObject::tr("File"), "options.ui.notifications.passive-popups.delays.file",
+			PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.file").toInt()/1000, AlertFile)
+	<< OptionValue(QObject::tr("Chat Message"), "options.ui.notifications.passive-popups.delays.chat",
+			PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.chat").toInt()/1000, AlertChat)
+	<< OptionValue(QObject::tr("Groupchat Message"),  "options.ui.notifications.passive-popups.delays.gc-message",
+			PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.gc-message").toInt()/1000, AlertGcHighlight);
+
+	d->options_ += initList;
+}
+
+PopupManager::~PopupManager()
+{
+	delete d;
+}
+
+int PopupManager::registerOption(const QString& name, int initValue, const QString& path)
+{	
+	foreach(const OptionValue& v, d->options_) {
+		if(v.optionName == name)
+			return v.id;
+	}
+
+	OptionValue ov(name, path, initValue, ++d->lastCustomType_);
+	d->options_.append(ov);
+
+	return ov.id;
+}
+
+void PopupManager::unregisterOption(const QString &name)
+{
+	OptionValue ov(name, "", 0, 0);
+	d->options_.removeAll(ov);
+}
+
+void PopupManager::setValue(const QString& name, int value)
+{	
+	QList<OptionValue>::iterator i = d->options_.begin();
+	for(; i != d->options_.end(); ++i) {
+		if((*i).optionName == name) {
+			(*i).optionValue = value;
+		}
+	}
+}
+
+int PopupManager::value(const QString& name) const
+{
+	foreach(const OptionValue& v, d->options_) {
+		if(v.optionName == name)
+			return v.optionValue;
+	}
+
+	return defaultTimeout;
+}
+
+const QString PopupManager::optionPath(const QString& name) const
+{	
+	foreach(const OptionValue& v, d->options_) {
+		if(v.optionName == name)
+			return v.optionPath;
+	}
+
+	return QString();
+}
+
+const QStringList PopupManager::optionsNamesList() const
+{
+	QStringList ret;
+	foreach(const OptionValue& v, d->options_)
+		ret.append(v.optionName);
+
+	return ret;
+}
+
+bool PopupManager::noPopup(PsiAccount *account) const
+{
+	if(account) {
+		if(account->noPopup())
+			return true;
+	}
+	else {
+		Status::Type type = d->psi_->currentStatusType();
+		if((type == Status::DND && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.suppress-while-dnd").toBool())
+			|| ( (type == Status::Away || type == Status::XA) &&
+			     PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.suppress-while-away").toBool() ))
+			{
+			return true;
+		}
+	}
+	return false;
+}
+
+void PopupManager::doPopup(PsiAccount *account, PopupType pType, const Jid &j, const Resource &r,
+			   UserListItem *u, PsiEvent *e, bool checkNoPopup)
+{
+	if (!PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.enabled").toBool())
+		return;
+
+	if(checkNoPopup && noPopup(account))
+		return;
+
+	NotificationsType type = currentType();
+	if(type == Default) {
+		PsiPopup *popup = new PsiPopup(this, pType, account);
+		popup->setData(j, r, u, e);
+	}
+#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
+	else if(type == Growl) {
+		PsiGrowlNotifier::instance()->popup(account, pType, j, r, u, e);
+	}
+#endif
+#ifdef USE_DBUS
+	else if(type == DBus) {
+		PsiDBusNotifier *db = new PsiDBusNotifier(this);
+		db->popup(account, pType, j, r, u, e);
+	}
+#endif
+}
+
+void PopupManager::doPopup(PsiAccount *account, const Jid &j, const PsiIcon *titleIcon, const QString &titleText,
+			   const QPixmap *avatar, const PsiIcon *icon, const QString &text, bool checkNoPopup, PopupType pType)
+{
+	Q_UNUSED(avatar)
+	Q_UNUSED(icon)
+
+	if (!PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.enabled").toBool())
+		return;
+
+	if(checkNoPopup && noPopup(account))
+		return;
+
+	NotificationsType type = currentType();
+	if(type == Default) {
+		PsiPopup *popup = new PsiPopup(this, titleIcon, titleText, account, pType);
+		popup->setJid(j);
+		popup->setData(avatar, icon, text);
+	}
+#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
+	else if(type == Growl) {
+		PsiGrowlNotifier::instance()->popup(account, j, titleIcon, titleText, text);
+	}
+#endif
+#ifdef USE_DBUS
+	else if(type == DBus) {
+		PsiDBusNotifier *db = new PsiDBusNotifier(this);
+		db->popup(account, j, titleIcon, titleText, avatar, icon, text, pType);
+	}
+#endif
+}
+
+
+QList< PopupManager::NotificationsType > PopupManager::availableTypes()
+{
+	if(availableTypes_.isEmpty()) {
+		availableTypes_ << Default;
+#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
+		availableTypes_ << Growl;
+#endif
+#ifdef USE_DBUS
+		if(PsiDBusNotifier::isAvailable())
+			availableTypes_ << DBus;
+#endif
+	}
+	return availableTypes_;
+}
+
+PopupManager::NotificationsType PopupManager::currentType()
+{
+	NotificationsType type = (NotificationsType)PsiOptions::instance()->getOption("options.ui.notifications.type").toInt();
+	if(availableTypes().contains(type))
+		return type;
+
+	return Default;
+}
+
+QString PopupManager::nameByType(NotificationsType type)
+{
+	QString ret;
+	switch(type) {
+	case Default:
+		ret = QObject::tr("Classic");
+		break;
+	case Growl:
+		ret = QObject::tr("Growl");
+		break;
+	case DBus:
+		ret = QObject::tr("DBus");
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+QString PopupManager::clipText(QString text)
+{
+	int len = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-text-length").toInt();
+	if (len > 0) {
+		// richtext will give us trouble here
+		if (((int)text.length()) > len) {
+			text = text.left(len);
+
+			// delete last unclosed tag
+			/*if ( text.find("</") > text.find(">") ) {
+
+				text = text.left( text.find("</") );
+			}*/
+
+			text += "...";
+		}
+	}
+
+	return text;
+}
+
+int PopupManager::timeout(PopupType type) const
+{
+	if(type == AlertMessage || type == AlertAvCall)
+		type = AlertChat;
+	else if(type == AlertOffline || type == AlertStatusChange || type == AlertNone || type == AlertComposing)
+		type = AlertOnline;
+
+	foreach(const OptionValue& v, d->options_)
+		if(v.id == type)
+			return v.optionValue*1000;
+
+	return defaultTimeout*1000;
+}
+
+QList< PopupManager::NotificationsType > PopupManager::availableTypes_ = QList< NotificationsType >();
--- psi.orig/src/popupmanager.h
+++ psi/src/popupmanager.h
@@ -0,0 +1,97 @@
+/*
+ * popupmanager.h
+ * Copyright (C) 2011-2012  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef POPUPMANAGER_H
+#define POPUPMANAGER_H
+
+#include <QStringList>
+
+class PsiAccount;
+class PsiCon;
+class UserListItem;
+class PsiEvent;
+class PsiIcon;
+class QPixmap;
+
+namespace XMPP {
+	class Jid;
+	class Resource;
+}
+using namespace XMPP;
+
+class PopupManager
+{
+public:
+	PopupManager(PsiCon* psi);
+	~PopupManager();
+
+	enum PopupType {
+		AlertNone = 0,
+
+		AlertOnline = 1,
+		AlertOffline = 2,
+		AlertStatusChange = 3,
+
+		AlertMessage = 4,
+		AlertComposing = 5,
+		AlertChat = 6,
+		AlertHeadline = 7,
+		AlertFile = 8,
+		AlertAvCall = 9,
+		AlertGcHighlight = 10,
+		AlertCustom = 11
+	};
+
+	enum NotificationsType {
+		Default = 0,
+		Growl = 1,
+		DBus = 2
+	};
+
+	int registerOption(const QString& name, int initValue = 5, const QString& path = QString());
+	void unregisterOption(const QString& name);
+	void setValue(const QString& name, int value);
+	int value(const QString& name) const;
+	const QString optionPath(const QString& name) const;
+	const QStringList optionsNamesList() const;
+
+	static QList< NotificationsType > availableTypes();
+	static NotificationsType currentType();
+	static QString nameByType(NotificationsType type);
+	static QString clipText(QString text);
+
+	void doPopup(PsiAccount* account, PopupType type, const Jid& j, const Resource& r,
+			    UserListItem* u = 0, PsiEvent* e = 0, bool checkNoPopup = true);
+	void doPopup(PsiAccount *account, const Jid &j, const PsiIcon *titleIcon, const QString& titleText,
+			    const QPixmap *avatar, const PsiIcon *icon, const QString& text, bool checkNoPopup = true, PopupType type = AlertNone);
+
+	int timeout(PopupType type) const;
+
+private:
+	bool noPopup(PsiAccount *account) const;
+
+private:
+	class Private;
+	Private* d;
+
+	static QList< NotificationsType > availableTypes_;
+};
+
+#endif
--- psi.orig/src/psiaccount.cpp
+++ psi/src/psiaccount.cpp
@@ -121,7 +121,6 @@
 #include "qwextend.h"
 #include "geolocationdlg.h"
 //#include "physicallocation.h"
-#include "psipopup.h"
 #include "translationmanager.h"
 #include "irisprotocol/iris_discoinfoquerier.h"
 #include "iconwidget.h"
@@ -153,6 +152,7 @@
 #include "bookmarkmanagedlg.h"
 #include "accountloginpassword.h"
 #include "alertmanager.h"
+#include "popupmanager.h"
 
 #include "psimedia/psimedia.h"
 #include "avcall/avcall.h"
@@ -164,10 +164,6 @@
 
 #include <QtCrypto>
 
-#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
-#include "psigrowlnotifier.h"
-#endif
-
 #include "bsocket.h"
 /*#ifdef Q_WS_WIN
 #include <windows.h>
@@ -500,6 +496,27 @@ public:
 			return true;
 
 		if (lastManualStatus().isAvailable()) {
+			if (lastManualStatus().type() == XMPP::Status::DND &&
+			    PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.suppress-while-dnd").toBool())
+			{
+				return true;
+			}
+			if ((lastManualStatus().type() == XMPP::Status::Away || lastManualStatus().type() == XMPP::Status::XA) &&
+			    PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.suppress-while-away").toBool())
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	bool noPopupDialogs(ActivationType activationType) const
+	{
+		if (activationType == FromXml || !doPopups_)
+			return true;
+
+		if (lastManualStatus().isAvailable()) {
 			if (lastManualStatus().type() == XMPP::Status::DND)
 				return true;
 			if ((lastManualStatus().type() == XMPP::Status::Away || lastManualStatus().type() == XMPP::Status::XA) &&
@@ -2432,34 +2449,24 @@ void PsiAccount::client_resourceAvailabl
 	if(doSound)
 		playSound(eOnline);
 
-#if !defined(Q_WS_MAC) || !defined(HAVE_GROWL)
 	// Do the popup test earlier (to avoid needless JID lookups)
 	if ((popupType == PopupOnline && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.online").toBool()) || (popupType == PopupStatusChange && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.other-changes").toBool())) {
-#endif
 		if(notifyOnlineOk && doPopup && !d->blockTransportPopupList->find(j, popupType == PopupOnline) && !d->noPopup(IncomingStanza)) {
-			QString name;
 			UserListItem *u = findFirstRelevant(j);
-
-			PsiPopup::PopupType pt = PsiPopup::AlertNone;
+			PopupManager::PopupType pt = PopupManager::AlertNone;
 			if ( popupType == PopupOnline )
-				pt = PsiPopup::AlertOnline;
+				pt = PopupManager::AlertOnline;
 			else if ( popupType == PopupStatusChange )
-				pt = PsiPopup::AlertStatusChange;
+				pt = PopupManager::AlertStatusChange;
 
 			if ((popupType == PopupOnline && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.online").toBool()) || (popupType == PopupStatusChange && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.other-changes").toBool())) {
-				PsiPopup *popup = new PsiPopup(pt, this);
-				popup->setData(j, r, u);
+				psi()->popupManager()->doPopup(this, pt, j, r, u, false);
 			}
-#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
-			PsiGrowlNotifier::instance()->popup(this, pt, j, r, u);
-#endif
 		}
 		else if ( !notifyOnlineOk ) {
 			d->userCounter++;
 		}
-#if !defined(Q_WS_MAC) || !defined(HAVE_GROWL)
 	}
-#endif
 
 	// Update entity capabilities.
 	// This has to happen after the userlist item has been created.
@@ -2536,21 +2543,14 @@ void PsiAccount::client_resourceUnavaila
 	if(doSound)
 		playSound(eOffline);
 
-#if !defined(Q_WS_MAC) || !defined(HAVE_GROWL)
 	// Do the popup test earlier (to avoid needless JID lookups)
-	if (PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.offline").toBool())
-#endif
-	if(doPopup && !d->blockTransportPopupList->find(j) && !d->noPopup(IncomingStanza)) {
-		QString name;
+	if(PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.offline").toBool() &&
+	   doPopup && !d->blockTransportPopupList->find(j) && !d->noPopup(IncomingStanza)) {
 		UserListItem *u = findFirstRelevant(j);
 
 		if (PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.status.offline").toBool()) {
-			PsiPopup *popup = new PsiPopup(PsiPopup::AlertOffline, this);
-			popup->setData(j, r, u);
+			psi()->popupManager()->doPopup(this, PopupManager::AlertOffline, j, r, u, false);
 		}
-#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
-		PsiGrowlNotifier::instance()->popup(this, PsiPopup::AlertOffline, j, r, u);
-#endif
 	}
 }
 
@@ -2975,6 +2975,11 @@ void PsiAccount::setStatusActual(const S
 	}
 }
 
+bool PsiAccount::noPopup() const
+{
+	return d->noPopup(UserAction);
+}
+
 void PsiAccount::sentInitialPresence()
 {
 	QTimer::singleShot(15000, this, SLOT(enableNotifyOnline()));
@@ -4761,7 +4766,7 @@ void PsiAccount::handleEvent(PsiEvent* e
 
 	bool doPopup    = false;
 	bool putToQueue = true;
-	PsiPopup::PopupType popupType = PsiPopup::AlertNone;
+	PopupManager::PopupType popupType = PopupManager::AlertNone;
 	SoundType soundType = eNone;
 
 	// find someone to accept the event
@@ -4861,8 +4866,15 @@ void PsiAccount::handleEvent(PsiEvent* e
 					c->incomingMessage(m);
 				}
 			}
-			delete e;
-			return;
+			if(m.chatState() == StateComposing) {
+				doPopup = true;
+				putToQueue = false;
+				popupType = PopupManager::AlertComposing;
+			}
+			else {
+				delete e;
+				return;
+			}
 		}
 		else if (m.messageReceipt() == ReceiptReceived) {
 			if (PsiOptions::instance()->getOption("options.ui.notifications.request-receipts").toBool()) {
@@ -4879,7 +4891,7 @@ void PsiAccount::handleEvent(PsiEvent* e
 		}
 
 		// pass chat messages directly to a chat window if possible (and deal with sound)
-		if(m.type() == "chat") {
+		else if(m.type() == "chat") {
 			ChatDlg *c = findChatDialog(e->from());
 			if(!c)
 				c = findChatDialog(e->jid());
@@ -4919,18 +4931,18 @@ void PsiAccount::handleEvent(PsiEvent* e
 
 			if (putToQueue) {
 				doPopup = true;
-				popupType = PsiPopup::AlertChat;
+				popupType = PopupManager::AlertChat;
 			}
 		} // /chat
 		else if (m.type() == "headline") {
 			soundType = eHeadline;
 			doPopup = true;
-			popupType = PsiPopup::AlertHeadline;
+			popupType = PopupManager::AlertHeadline;
 		} // /headline
 		else if (m.type().isEmpty()) {
 			soundType = eMessage;
 			doPopup = true;
-			popupType = PsiPopup::AlertMessage;
+			popupType = PopupManager::AlertMessage;
 		} // /""
 		else {
 			soundType = eSystem;
@@ -4947,12 +4959,12 @@ void PsiAccount::handleEvent(PsiEvent* e
 	else if(e->type() == PsiEvent::File) {
 		soundType = eIncomingFT;
 		doPopup = true;
-		popupType = PsiPopup::AlertFile;
+		popupType = PopupManager::AlertFile;
 	}
 	else if(e->type() == PsiEvent::AvCallType) {
 		soundType = eIncomingFT;
 		doPopup = true;
-		popupType = PsiPopup::AlertAvCall;
+		popupType = PopupManager::AlertAvCall;
 	}
 	else if(e->type() == PsiEvent::RosterExchange) {
 		RosterExchangeEvent* re = (RosterExchangeEvent*) e;
@@ -5027,18 +5039,16 @@ void PsiAccount::handleEvent(PsiEvent* e
 			r = *(u->priority());
 		}
 
-		if ((popupType == PsiPopup::AlertChat     && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-chat").toBool())     ||
-		    (popupType == PsiPopup::AlertMessage  && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-message").toBool())  ||
-		    (popupType == PsiPopup::AlertHeadline && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-headline").toBool()) ||
-		    (popupType == PsiPopup::AlertFile     && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-file-transfer").toBool()) ||
-		    (popupType == PsiPopup::AlertAvCall   && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-message").toBool()))
+		if ((popupType == PopupManager::AlertChat      && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-chat").toBool())     ||
+		    (popupType == PopupManager::AlertMessage   && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-message").toBool())  ||
+		    (popupType == PopupManager::AlertHeadline  && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-headline").toBool()) ||
+		    (popupType == PopupManager::AlertFile      && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-file-transfer").toBool()) ||
+		    (popupType == PopupManager::AlertAvCall    && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.incoming-message").toBool()) ||
+		    (popupType == PopupManager::AlertComposing && PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.composing").toBool()))
 		{
-			PsiPopup *popup = new PsiPopup(popupType, this);
-			popup->setData(j, r, u, e);
+			psi()->popupManager()->doPopup(this, popupType, j, r, u, e, false);
 		}
-#if defined(Q_WS_MAC) && defined(HAVE_GROWL)
-		PsiGrowlNotifier::instance()->popup(this, popupType, j, r, u, e);
-#endif
+
 		emit startBounce();
 	}
 
@@ -5192,7 +5202,7 @@ void PsiAccount::queueEvent(PsiEvent* e,
 
 	// FIXME: We shouldn't be doing this kind of stuff here, because this
 	// function is named *queue*Event() not deleteThisMessageSometimes()
-	if (!d->noPopup(activationType)) {
+	if (!d->noPopupDialogs(activationType)) {
 		bool doPopup = false;
 
 		// Check to see if we need to popup
--- psi.orig/src/psiaccount.h
+++ psi/src/psiaccount.h
@@ -139,6 +139,7 @@ public:
 	int defaultPriority(const XMPP::Status &);
 	void setStatusDirect(const XMPP::Status &, bool withPriority = false);
 	void setStatusActual(const XMPP::Status &);
+	bool noPopup() const;
 	bool loggedIn() const;
 	void setNick(const QString &);
 	QString nick() const;
--- psi.orig/src/psicon.cpp
+++ psi/src/psicon.cpp
@@ -110,6 +110,7 @@
 #include "avcall/calldlg.h"
 #include "alertmanager.h"
 #include "bosskey.h"
+#include "popupmanager.h"
 
 #include "AutoUpdater/AutoUpdater.h"
 #ifdef HAVE_SPARKLE
@@ -222,6 +223,7 @@ public:
 		, quitting(false)
 		, alertManager(parent)
 		, bossKey(0)
+		, popupManager(0)
 	{
 		psi = parent;
 	}
@@ -300,6 +302,7 @@ public:
 	AutoUpdater *autoUpdater;
 	AlertManager alertManager;
 	BossKey *bossKey;
+	PopupManager * popupManager;
 };
 
 //----------------------------------------------------------------------------
@@ -345,6 +348,7 @@ PsiCon::~PsiCon()
 	delete d->edb;
 	delete d->defaultMenuBar;
 	delete d->tabManager;
+	delete d->popupManager;
 	delete d;
 }
 
@@ -548,6 +552,9 @@ bool PsiCon::init()
 
 	d->idle.start();
 
+	//PopupDurationsManager
+	d->popupManager = new PopupManager(this);
+
 	// S5B
 	d->s5bServer = new S5BServer;
 	s5b_init();
@@ -787,6 +794,11 @@ FileTransDlg *PsiCon::ftdlg() const
 #endif
 }
 
+PopupManager* PsiCon::popupManager() const
+{
+	return d->popupManager;
+}
+
 TabManager *PsiCon::tabManager() const
 {
 	return d->tabManager;
--- psi.orig/src/psicon.h
+++ psi/src/psicon.h
@@ -56,6 +56,7 @@ class TuneController;
 class PsiContactList;
 class TabManager;
 class ContactUpdatesManager;
+class PopupManager;
 
 namespace OpenPGP {
 	class Engine;
@@ -127,6 +128,8 @@ public:
 	bool haveAutoUpdater() const;
 	void updateStatusPresets();
 
+	PopupManager* popupManager() const;
+
 signals:
 	void quit(int);
 	void accountAdded(PsiAccount *);
--- psi.orig/src/psidbusnotifier.cpp
+++ psi/src/psidbusnotifier.cpp
@@ -0,0 +1,377 @@
+/*
+ * psidbusnotifier.cpp: Psi's interface to org.freedesktop.Notify
+ * Copyright (C) 2012  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * You can also redistribute and/or modify this program under the
+ * terms of the Psi License, specified in the accompanied COPYING
+ * file, as published by the Psi Project; either dated January 1st,
+ * 2005, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+
+#include <QDBusConnection>
+#include <QDBusMessage>
+#include <QDBusInterface>
+#include <QDBusArgument>
+#include <QDBusMetaType>
+#include <QDBusReply>
+#include <QCoreApplication>
+#include <QImage>
+
+#include "psidbusnotifier.h"
+#include "psiaccount.h"
+#include "psievent.h"
+#include "common.h"
+#include "avatars.h"
+#include "userlist.h"
+#include "applicationinfo.h"
+#include "psipopup.h"
+#include "psioptions.h"
+#include "psicon.h"
+
+
+static int minLifeTime = 5000;
+
+class iiibiiay
+{
+public:
+	iiibiiay(QImage* img)
+	{
+		if(img->format() != QImage::Format_ARGB32)
+			*img = img->convertToFormat(QImage::Format_ARGB32);
+		width = img->width();
+		height = img->height();
+		rowstride = img->bytesPerLine();
+		hasAlpha = img->hasAlphaChannel();
+		channels = img->isGrayscale()?1:hasAlpha?4:3;
+		bitsPerSample = img->depth()/channels;
+		image.append((char*)img->rgbSwapped().bits(),img->numBytes());
+	}
+	iiibiiay(){}
+	static const int id;
+	int width;
+	int height;
+	int rowstride;
+	bool hasAlpha;
+	int bitsPerSample;
+	int channels;
+	QByteArray image;
+};
+Q_DECLARE_METATYPE(iiibiiay);
+
+const int iiibiiay::id(qDBusRegisterMetaType<iiibiiay>());
+
+QDBusArgument &operator<<(QDBusArgument &a, const iiibiiay &i)
+{
+	a.beginStructure();
+	a << i.width << i.height << i.rowstride << i.hasAlpha << i.bitsPerSample << i.channels << i.image;
+	a.endStructure();
+	return a;
+}
+const QDBusArgument & operator >>(const QDBusArgument &a,  iiibiiay &i)
+{
+	a.beginStructure();
+	a >> i.width >> i.height >> i.rowstride >> i.hasAlpha >> i.bitsPerSample >> i.channels >> i.image;
+	a.endStructure();
+	return a;
+}
+
+static QDBusMessage createMessage(const QString& method)
+{
+	return QDBusMessage::createMethodCall("org.freedesktop.Notifications",
+					     "/org/freedesktop/Notifications",
+					    "org.freedesktop.Notifications",
+					    method);
+}
+
+
+PsiDBusNotifier::PsiDBusNotifier(PopupManager *manager)
+	: QObject(QCoreApplication::instance())
+	, pm_(manager)
+	, id_(0)
+	, account_(0)
+	, event_(0)
+	, lifeTimer_(new QTimer(this))
+{
+	QDBusConnection::sessionBus().connect("org.freedesktop.Notifications",
+					      "/org/freedesktop/Notifications",
+					      "org.freedesktop.Notifications",
+					      "NotificationClosed", this, SLOT(popupClosed(uint,uint)));
+	lifeTimer_->setSingleShot(true);
+	connect(lifeTimer_, SIGNAL(timeout()), SLOT(readyToDie()));
+}
+
+PsiDBusNotifier::~PsiDBusNotifier()
+{
+}
+
+bool PsiDBusNotifier::isAvailable()
+{
+	static bool ret = QDBusInterface("org.freedesktop.Notifications",
+					   "/org/freedesktop/Notifications",
+					   "org.freedesktop.Notifications",
+					   QDBusConnection::sessionBus()).isValid();
+	return ret;
+}
+
+void PsiDBusNotifier::popup(PsiAccount* account, PopupManager::PopupType type, const Jid& jid, const Resource& r, const UserListItem* uli, PsiEvent* event)
+{
+	account_ = account;
+	jid_ = jid;
+	if(event) {
+		event_ = event;
+		connect(event_, SIGNAL(destroyed()), SLOT(eventDestroyed()));
+	}
+
+	QString title, desc, contact, text, statusMsg;
+	QString statusTxt = status2txt(makeSTATUS(r.status()));
+	int len = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt();
+	if (len != 0)
+		statusMsg = r.status().status();
+	if (len > 0)
+		if (((int)statusMsg.length()) > len)
+			statusMsg = statusMsg.left(len) + "...";
+	bool doAlert = false;
+	PsiIcon* ico = 0;
+
+	if (uli && !uli->name().isEmpty()) {
+		contact = uli->name();
+	}
+	else if (event && event->type() == PsiEvent::Auth) {
+		contact = ((AuthEvent*) event)->nick();
+	}
+	else if (event && event->type() == PsiEvent::Message) {
+		contact = ((MessageEvent*) event)->nick();
+	}
+
+	QString j = jid.full();
+	int jidLen = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt();
+	if (jidLen > 0 && ((int)j.length()) > jidLen)
+		j = j.left(jidLen) + "...";
+
+	if(contact.isEmpty()) {
+		contact = j;
+	}
+	else {
+		contact = QString("%1<%2>").arg(contact, j);
+	}
+
+	title = PsiPopup::title(type, &doAlert, &ico);
+
+	QVariantMap hints;
+	if(PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.dbus.transient-hint").toBool() ||
+	   type == PopupManager::AlertComposing || type == PopupManager::AlertOffline ||
+	   type == PopupManager::AlertOnline || type == PopupManager::AlertStatusChange || type == PopupManager::AlertNone)
+	{
+		hints.insert("transient", QVariant(true));
+	}
+//	if(doAlert) {
+//		hints.insert("urgency", QVariant(2));
+//	}
+	QImage im;
+	if(account) {
+		im = account->avatarFactory()->getAvatar(jid.bare()).toImage();
+		if(!im.isNull()) {
+			int size = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.avatar-size").toInt();
+			im = im.scaledToWidth(size, Qt::SmoothTransformation);
+		}
+	}
+
+	if(im.isNull() && ico) {
+		im = ico->pixmap().toImage();
+	}
+
+	if(!im.isNull()) {
+		iiibiiay i(&im);
+		hints.insert("icon_data", QVariant(iiibiiay::id, &i));
+	}
+
+	bool showMessage = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.showMessage").toBool();
+
+	switch(type) {
+	case PopupManager::AlertOnline:
+		text = QString("%1 (%2)").arg(contact).arg(statusTxt);
+		desc = statusMsg;
+		break;
+	case PopupManager::AlertOffline:
+		text = QString("%1 (%2)").arg(contact).arg(statusTxt);
+		desc = statusMsg;
+		break;
+	case PopupManager::AlertStatusChange:
+		text = QString("%1 (%2)").arg(contact).arg(statusTxt);
+		desc = statusMsg;
+		break;
+	case PopupManager::AlertComposing:
+		text = QString("%1%2").arg(contact).arg(QObject::tr(" is typing..."));
+		desc = "";
+		break;
+	case PopupManager::AlertMessage:
+	case PopupManager::AlertChat:
+	case PopupManager::AlertGcHighlight:
+		{
+			text = QObject::tr("%1 says:").arg(contact);
+			if(showMessage) {
+				const Message* jmessage = &((MessageEvent *)event)->message();
+				desc = jmessage->body();
+			}
+			break;
+		}
+	case PopupManager::AlertHeadline: {
+			text = QObject::tr("Headline from %1").arg(contact);
+			if(showMessage) {
+				const Message* jmessage = &((MessageEvent *)event)->message();
+				if ( !jmessage->subject().isEmpty())
+					title = jmessage->subject();
+				desc = jmessage->body();
+			}
+			break;
+		}
+	case PopupManager::AlertFile:
+		text = QObject::tr("Incoming file from %1").arg(contact);
+		break;
+	case PopupManager::AlertAvCall:
+		text = QObject::tr("Incoming call from %1").arg(contact);
+		break;
+	default:
+		break;
+	}
+
+	if(!desc.isEmpty()) {
+		desc = PopupManager::clipText(desc);
+		text += "\n" + desc;
+	}
+
+	int lifeTime = pm_->timeout(type);
+	QDBusMessage m = createMessage("Notify");
+	QVariantList args;
+	args << QString(ApplicationInfo::name());
+	args << QVariant(QVariant::UInt);
+	args << QVariant("");
+	args << QString(title);
+	args << QString(text);
+	args << QStringList();
+	args << hints;
+	args << lifeTime;
+	m.setArguments(args);
+	QDBusPendingCall call = QDBusConnection::sessionBus().asyncCall(m);
+	QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(call, this);
+
+	connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)),
+			 this, SLOT(asyncCallFinished(QDBusPendingCallWatcher*)));
+
+	lifeTime = (lifeTime < 0) ? lifeTime : qMax(minLifeTime, lifeTime);
+	if(lifeTime >= 0)
+		lifeTimer_->start(lifeTime);
+}
+
+void PsiDBusNotifier::popup(PsiAccount *account, const Jid &jid, const PsiIcon *titleIcon, const QString &titleText,
+			    const QPixmap *avatar, const PsiIcon */*icon*/, const QString &text, PopupManager::PopupType type)
+{
+	account_ = account;
+	jid_ = jid;
+
+	QVariantMap hints;
+	if(PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.dbus.transient-hint").toBool()) {
+		hints.insert("transient", QVariant(true));
+	}
+	if(avatar || titleIcon) {
+		int size = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.avatar-size").toInt();
+		QImage im = avatar ? avatar->toImage().scaledToWidth(size, Qt::SmoothTransformation) : titleIcon->pixmap().toImage();
+		iiibiiay i(&im);
+		hints.insert("icon_data", QVariant(iiibiiay::id, &i));
+	}
+
+	int lifeTime = pm_->timeout(type);
+	QDBusMessage m = createMessage("Notify");
+	QVariantList args;
+	args << QString(ApplicationInfo::name());
+	args << QVariant(QVariant::UInt);
+	args << QVariant("");
+	args << QString(titleText);
+	args << QString(text);
+	args << QStringList();
+	args << hints;
+	args << lifeTime;
+	m.setArguments(args);
+	QDBusPendingCall call = QDBusConnection::sessionBus().asyncCall(m);
+	QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(call, this);
+
+	connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)),
+			 this, SLOT(asyncCallFinished(QDBusPendingCallWatcher*)));
+
+	lifeTime = (lifeTime < 0) ? lifeTime : qMax(minLifeTime, lifeTime);
+	if(lifeTime >= 0)
+		lifeTimer_->start(lifeTime);
+}
+
+void PsiDBusNotifier::asyncCallFinished(QDBusPendingCallWatcher *watcher)
+{
+	QDBusMessage m = watcher->reply();
+	if(m.type() == QDBusMessage::InvalidMessage || m.arguments().isEmpty()) {
+		readyToDie();
+		return;
+	}
+
+	QVariant repl = m.arguments().first();
+	if(repl.type() != QVariant::UInt || repl.toUInt() == 0) {
+		readyToDie();
+	}
+	else {
+		id_ = repl.toUInt();
+	}
+}
+
+void PsiDBusNotifier::popupClosed(uint id, uint reason)
+{
+	if(id_ != 0 && id_ == id) {
+		if(reason == 2) {
+			if(account_) {
+				if(event_) {
+					account_->psi()->processEvent(event_, UserAction);
+				}
+				else if(jid_.isValid()) {
+					account_->actionDefault(Jid(jid_.bare()));
+				}
+			}
+		}
+		readyToDie();
+	}
+}
+
+void PsiDBusNotifier::eventDestroyed()
+{
+	event_ = 0;
+}
+
+void PsiDBusNotifier::readyToDie()
+{
+	if(lifeTimer_->isActive()) {
+		lifeTimer_->stop();
+	}
+
+	QDBusConnection::sessionBus().disconnect("org.freedesktop.Notifications",
+						 "/org/freedesktop/Notifications",
+						 "org.freedesktop.Notifications",
+						 "NotificationClosed", this, SLOT(popupClosed(uint,uint)));
+
+	if(event_) {
+		disconnect(event_, SIGNAL(destroyed()), this, SLOT(eventDestroyed()));
+	}
+
+	deleteLater();
+}
--- psi.orig/src/psidbusnotifier.h
+++ psi/src/psidbusnotifier.h
@@ -0,0 +1,64 @@
+/*
+ * psidbusnotifier.h: Psi's interface to org.freedesktop.Notify
+ * Copyright (C) 2012  Khryukin Evgeny
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * You can also redistribute and/or modify this program under the
+ * terms of the Psi License, specified in the accompanied COPYING
+ * file, as published by the Psi Project; either dated January 1st,
+ * 2005, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSIDBUSNOTIFIER_H
+#define PSIDBUSNOTIFIER_H
+
+#include "popupmanager.h"
+#include "xmpp/jid/jid.h"
+
+class QDBusPendingCallWatcher;
+class QTimer;
+
+using namespace XMPP;
+
+class PsiDBusNotifier : public QObject
+{
+	Q_OBJECT
+
+public:
+	PsiDBusNotifier(PopupManager* manager);
+	~PsiDBusNotifier();
+	static bool isAvailable();
+	void popup(PsiAccount* account, PopupManager::PopupType type, const Jid& j, const Resource& r, const UserListItem* = 0, PsiEvent* = 0);
+	void popup(PsiAccount *account, const Jid &j, const PsiIcon *titleIcon, const QString& titleText,
+				    const QPixmap *avatar, const PsiIcon *icon, const QString& text, PopupManager::PopupType type);
+
+private slots:
+	void popupClosed(uint id, uint reason);
+	void eventDestroyed();
+	void asyncCallFinished(QDBusPendingCallWatcher*);
+	void readyToDie();
+
+private:
+	PopupManager* pm_;
+	Jid jid_;
+	uint id_;
+	PsiAccount *account_;
+	PsiEvent *event_;
+	QTimer *lifeTimer_;
+};
+
+#endif
--- psi.orig/src/psigrowlnotifier.cpp
+++ psi/src/psigrowlnotifier.cpp
@@ -33,6 +33,7 @@
 #include "psigrowlnotifier.h"
 #include "psievent.h"
 #include "userlist.h"
+#include "psioptions.h"
 
 /**
  * A class representing the notification context, which will be passed to
@@ -42,8 +43,8 @@ class NotificationContext
 {
 public:
 	NotificationContext(PsiAccount* a, Jid j) : account_(a), jid_(j), deleteCount_(0) { }
-	PsiAccount* account() { return account_; }
-	Jid jid() { return jid_; }
+	PsiAccount* account() const { return account_; }
+	Jid jid() const { return jid_; }
 
 private:
 	PsiAccount* account_;
@@ -106,79 +107,126 @@ PsiGrowlNotifier* PsiGrowlNotifier::inst
  * \param uli The originating userlist item. Can be NULL.
  * \param event The originating event. Can be NULL.
  */
-void PsiGrowlNotifier::popup(PsiAccount* account, PsiPopup::PopupType type, const Jid& jid, const Resource& r, const UserListItem* uli, PsiEvent* event)
+void PsiGrowlNotifier::popup(PsiAccount* account, PopupManager::PopupType type, const Jid& jid, const Resource& r, const UserListItem* uli, PsiEvent* event)
 {
 	QString name;
 	QString title, desc, contact;
 	QString statusTxt = status2txt(makeSTATUS(r.status()));
-	QString statusMsg = r.status().status();
-	QPixmap icon = account->avatarFactory()->getAvatar(jid.bare());
+	QString statusMsg;
+	int len = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt();
+	if (len != 0)
+		statusMsg = r.status().status();
+	if (len > 0)
+		if (((int)statusMsg.length()) > len)
+			statusMsg = statusMsg.left(len) + "...";
+	QPixmap icon;
+	if(account)
+		icon = account->avatarFactory()->getAvatar(jid.bare());
+
 	if (uli) {
 		contact = uli->name();
 	}
-	else if (event->type() == PsiEvent::Auth) {
+	else if (event && event->type() == PsiEvent::Auth) {
 		contact = ((AuthEvent*) event)->nick();
 	}
-	else if (event->type() == PsiEvent::Message) {
+	else if (event && event->type() == PsiEvent::Message) {
 		contact = ((MessageEvent*) event)->nick();
 	}
 
 	if (contact.isEmpty())
 		contact = jid.bare();
 
+	int jidLen = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt();
+	if (jidLen > 0 && ((int)contact.length()) > jidLen)
+		contact = contact.left(jidLen) + "...";
+
 	// Default value for the title
 	title = contact;
 
+	bool showMessage = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.showMessage").toBool();
+
 	switch(type) {
-		case PsiPopup::AlertOnline:
+		case PopupManager::AlertOnline:
 			name = QObject::tr("Contact becomes Available");
 			title = QString("%1 (%2)").arg(contact).arg(statusTxt);
 			desc = statusMsg;
 			//icon = PsiIconset::instance()->statusPQString(jid, r.status());
 			break;
-		case PsiPopup::AlertOffline:
+		case PopupManager::AlertOffline:
 			name = QObject::tr("Contact becomes Unavailable");
 			title = QString("%1 (%2)").arg(contact).arg(statusTxt);
 			desc = statusMsg;
 			//icon = PsiIconset::instance()->statusPQString(jid, r.status());
 			break;
-		case PsiPopup::AlertStatusChange:
+		case PopupManager::AlertStatusChange:
 			name = QObject::tr("Contact changes Status");
 			title = QString("%1 (%2)").arg(contact).arg(statusTxt);
 			desc = statusMsg;
 			//icon = PsiIconset::instance()->statusPQString(jid, r.status());
 			break;
-		case PsiPopup::AlertMessage: {
+		case PopupManager::AlertComposing:
+			name = QObject::tr("Typing notify");
+			title = QString("%1%2").arg(contact).arg(QObject::tr(" is typing..."));
+			desc = QObject::tr("[Typing notify]");
+			//icon = (PsiIcon *)IconsetFactory::iconPtr("psi/typing");
+			break;
+		case PopupManager::AlertMessage: {
 			name = QObject::tr("Incoming Message");
 			title = QObject::tr("%1 says:").arg(contact);
-			const Message* jmessage = &((MessageEvent *)event)->message();
-			desc = jmessage->body();
+			if(showMessage) {
+				const Message* jmessage = &((MessageEvent *)event)->message();
+				desc = jmessage->body();
+			} else
+				desc = QObject::tr("[Incoming Message]");
 			//icon = IconsetFactory::iconPQString("psi/message");
 			break;
 		}
-		case PsiPopup::AlertChat: {
+		case PopupManager::AlertChat: {
 			name = QObject::tr("Incoming Message");
-			const Message* jmessage = &((MessageEvent *)event)->message();
-			desc = jmessage->body();
+			if(showMessage) {
+				const Message* jmessage = &((MessageEvent *)event)->message();
+				desc = jmessage->body();
+			} else
+				desc = QObject::tr("[Incoming Message]");
 			//icon = IconsetFactory::iconPQString("psi/start-chat");
 			break;
 		}
-		case PsiPopup::AlertHeadline: {
+		case PopupManager::AlertHeadline: {
 			name = QObject::tr("Incoming Headline");
 			const Message* jmessage = &((MessageEvent *)event)->message();
 			if ( !jmessage->subject().isEmpty())
 				title = jmessage->subject();
-			desc = jmessage->body();
+			if(showMessage) {
+				desc = jmessage->body();
+			} else
+				desc = QObject::tr("[Incoming Headline]");
 			//icon = IconsetFactory::iconPQString("psi/headline");
 			break;
 		}
-		case PsiPopup::AlertFile:
+		case PopupManager::AlertFile:
 			name = QObject::tr("Incoming File");
 			desc = QObject::tr("[Incoming File]");
 			//icon = IconsetFactory::iconPQString("psi/file");
 			break;
+		case PopupManager::AlertGcHighlight: {
+			name = QObject::tr("Groupchat highlight");
+			if(showMessage) {
+				const Message* jmessage = &((MessageEvent *)event)->message();
+				desc = jmessage->body();
+			} else
+				desc = QObject::tr("[Groupchat highlight]");
+			break;
+		}
+		case PopupManager::AlertAvCall:
+			name = QObject::tr("Incoming Call");
+			desc = QObject::tr("[Incoming Call]");
+			break;
 		default:
 			break;
+		}
+
+	if(!desc.isEmpty()) {
+		desc = PopupManager::clipText(desc);
 	}
 
 	// Notify Growl
@@ -186,6 +234,14 @@ void PsiGrowlNotifier::popup(PsiAccount*
 	gn_->notify(name, title, desc, icon, false, this, SLOT(notificationClicked(void*)), SLOT(notificationTimedOut(void*)), context);
 }
 
+void PsiGrowlNotifier::popup(PsiAccount *account, const Jid &jid, const PsiIcon *titleIcon, const QString &titleText, const QString &text)
+{
+	// Notify Growl
+	NotificationContext* context = new NotificationContext(account, jid);
+	gn_->notify(titleText, QString("[%1]").arg(titleText), text,
+		    titleIcon->pixmap(), false, this, SLOT(notificationClicked(void*)), SLOT(notificationTimedOut(void*)), context);
+}
+
 void PsiGrowlNotifier::cleanup()
 {
 	// try to keep the garbage bin no larger than 50 entries
@@ -210,7 +266,8 @@ void PsiGrowlNotifier::tryDeleteContext(
 void PsiGrowlNotifier::notificationClicked(void* c)
 {
 	NotificationContext* context = (NotificationContext*) c;
-	context->account()->actionDefault(context->jid());
+	if(context->account())
+		context->account()->actionDefault(context->jid());
 	//delete context;
 	tryDeleteContext(context);
 }
--- psi.orig/src/psigrowlnotifier.h
+++ psi/src/psigrowlnotifier.h
@@ -26,15 +26,13 @@
 #ifndef PSIGROWLNOTIFIER_H
 #define PSIGROWLNOTIFIER_H
 
-#include <QObject>
-
-#include "psipopup.h"
+#include "popupmanager.h"
 
 class GrowlNotifier;
-class PsiAccount;
-
 class NotificationContext;
 
+using namespace XMPP;
+
 /**
  * An interface for Psi to Growl.
  * This class uses GrowlNotifier to interface with Growl.
@@ -49,7 +47,8 @@ class PsiGrowlNotifier : public QObject
 
 public:
 	static PsiGrowlNotifier* instance();
-	void popup(PsiAccount* account, PsiPopup::PopupType type, const Jid& j, const Resource& r, const UserListItem* = 0, PsiEvent* = 0);
+	void popup(PsiAccount* account, PopupManager::PopupType type, const Jid& j, const Resource& r, const UserListItem* = 0, PsiEvent* = 0);
+	void popup(PsiAccount *account, const Jid &j, const PsiIcon *titleIcon, const QString& titleText, const QString& text);
 
 public slots:
 	void notificationClicked(void*);
--- psi.orig/src/psipopup.cpp
+++ psi/src/psipopup.cpp
@@ -66,9 +66,8 @@ public:
 	Private(PsiPopup *p);
 	~Private();
 
-	void init(const PsiIcon *titleIcon, QString titleText, PsiAccount *_acc, PopupType type);
-	QString clipText(QString);
-	QBoxLayout *createContactInfo(const QPixmap *avatar, const PsiIcon *icon, QString text);
+	void init(const PsiIcon *titleIcon, const QString& titleText, PsiAccount *_acc, PopupManager::PopupType type);
+	QBoxLayout *createContactInfo(const QPixmap *avatar, const PsiIcon *icon, const QString& text);
 
 private slots:
 	void popupDestroyed();
@@ -81,21 +80,25 @@ public:
 	FancyPopup *popup;
 	PsiPopup *psiPopup;
 	QString id;
-	PopupType popupType;
+	PopupManager::PopupType popupType;
 	Jid jid;
 	Status status;
 	PsiEvent *event;
 	PsiIcon *titleIcon;
 	bool display;
+	bool doAlertIcon;
 };
 
 PsiPopup::Private::Private(PsiPopup *p)
+	: psi(0)
+	, account(0)
+	, popup(0)
+	, psiPopup(p)
+	, popupType(PopupManager::AlertNone)
+	, event(0)
+	, titleIcon(0)
+	, doAlertIcon(false)
 {
-	psiPopup = p;
-	popup = 0;
-	popupType = AlertNone;
-	event = 0;
-	titleIcon = 0;
 }
 
 PsiPopup::Private::~Private()
@@ -110,15 +113,13 @@ PsiPopup::Private::~Private()
 	popup = 0;
 }
 
-void PsiPopup::Private::init(const PsiIcon *_titleIcon, QString titleText, PsiAccount *acc, PopupType type)
+void PsiPopup::Private::init(const PsiIcon *_titleIcon, const QString& titleText, PsiAccount *acc, PopupManager::PopupType type)
 {
-	psi = acc->psi();
+	if(acc)
+		psi = acc->psi();
 	account = acc;
 	display = true;
 
-	if ( !PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.enabled").toBool() )
-		return;
-
 	if ( !psiPopupList )
 		psiPopupList = new QList<PsiPopup *>();
 
@@ -129,30 +130,13 @@ void PsiPopup::Private::init(const PsiIc
 	if ( psiPopupList->count() && psiPopupList->last() )
 		lastPopup = psiPopupList->last()->popup();
 
-	if ( type != AlertNone )
+	if ( doAlertIcon )
 		titleIcon = new AlertIcon(_titleIcon);
 	else
 		titleIcon = new PsiIcon(*_titleIcon);
 
-//	FancyPopup::setHideTimeout( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.duration").toInt() );
-	switch(type)
-	{
-		case AlertMessage:
-			FancyPopup::setHideTimeout( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.message").toInt() );
-			break;
-		case AlertChat:
-		case AlertHeadline:
-		case AlertGcHighlight:
-			FancyPopup::setHideTimeout( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.chat").toInt() );
-			break;
-		case AlertFile:
-			FancyPopup::setHideTimeout( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.file").toInt() );
-			break;
-		default:
-			FancyPopup::setHideTimeout( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.delays.status").toInt() );
-			break;
-	}
-	FancyPopup::setBorderColor( ColorOpt::instance()->color("options.ui.look.colors.passive-popup.border") );
+	FancyPopup::setHideTimeout(psiPopup->pm_->timeout(type));
+	FancyPopup::setBorderColor(ColorOpt::instance()->color("options.ui.look.colors.passive-popup.border"));
 
 	popup = new FancyPopup(titleText, titleIcon, lastPopup, false);
 	connect(popup, SIGNAL(clicked(int)), SLOT(popupClicked(int)));
@@ -185,35 +169,16 @@ void PsiPopup::Private::popupClicked(int
 	else if ( event && event->account() && button == (int)Qt::RightButton ) {
 		event->account()->psi()->removeEvent(event);
 	}
-}
 
-void PsiPopup::Private::eventDestroyed()
-{
 	popup->deleteLater();
-	event = 0;
 }
 
-QString PsiPopup::Private::clipText(QString text)
+void PsiPopup::Private::eventDestroyed()
 {
-	if ( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-text-length").toInt() > 0 ) {
-		// richtext will give us trouble here
-		if ( ((int)text.length()) > PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-text-length").toInt() ) {
-			text = text.left( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-text-length").toInt() );
-
-			// delete last unclosed tag
-			/*if ( text.find("</") > text.find(">") ) {
-
-				text = text.left( text.find("</") );
-			}*/
-
-			text += "...";
-		}
-	}
-
-	return text;
+	event = 0;
 }
 
-QBoxLayout *PsiPopup::Private::createContactInfo(const QPixmap *avatar, const PsiIcon *icon, QString text)
+QBoxLayout *PsiPopup::Private::createContactInfo(const QPixmap *avatar, const PsiIcon *icon, const QString& text)
 {
 	QHBoxLayout *dataBox = new QHBoxLayout();
 
@@ -242,7 +207,7 @@ QBoxLayout *PsiPopup::Private::createCon
 	textLabel->setFont(font);
 
 	textLabel->setWordWrap(false);
-	textLabel->setText(QString("<qt>%1</qt>").arg(clipText(text)));
+	textLabel->setText(QString("<qt>%1</qt>").arg(PopupManager::clipText(text)));
 	textLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Maximum);
 	dataBox->addWidget(textLabel);
 
@@ -253,10 +218,11 @@ QBoxLayout *PsiPopup::Private::createCon
 // PsiPopup
 //----------------------------------------------------------------------------
 
-PsiPopup::PsiPopup(const PsiIcon *titleIcon, QString titleText, PsiAccount *acc)
+PsiPopup::PsiPopup(PopupManager* manager, const PsiIcon *titleIcon, const QString& titleText, PsiAccount *acc, PopupManager::PopupType type)
+	: pm_(manager)
 {
 	d = new Private(this);
-	d->init(titleIcon, titleText, acc, AlertNone);
+	d->init(titleIcon, titleText, acc, type);
 }
 
 PsiPopup::~PsiPopup()
@@ -264,61 +230,89 @@ PsiPopup::~PsiPopup()
 	delete d;
 }
 
-PsiPopup::PsiPopup(PopupType type, PsiAccount *acc)
+PsiPopup::PsiPopup(PopupManager* manager, PopupManager::PopupType type, PsiAccount *acc)
+	: pm_(manager)
 {
 	d = new Private(this);
 
 	d->popupType = type;
 	PsiIcon *icon = 0;
-	QString text = "Psi: ";
-	bool doAlertIcon = false;
+
+	QString text = title(type, &d->doAlertIcon, &icon);
+
+	d->init(icon, text, acc, type);
+}
+
+QString PsiPopup::title(PopupManager::PopupType type, bool *doAlertIcon, PsiIcon **icon)
+{
+	QString text;
 
 	switch(type) {
-	case AlertOnline:
-		text += PsiPopup::tr("Contact online");
-		icon = (PsiIcon *)IconsetFactory::iconPtr("status/online");
-		break;
-	case AlertOffline:
-		text += PsiPopup::tr("Contact offline");
-		icon = (PsiIcon *)IconsetFactory::iconPtr("status/offline");
-		break;
-	case AlertStatusChange:
-		text += PsiPopup::tr("Status change");
-		icon = (PsiIcon *)IconsetFactory::iconPtr("status/online");
-		break;
-	case AlertMessage:
-		text += PsiPopup::tr("Incoming message");
-		icon = (PsiIcon *)IconsetFactory::iconPtr("psi/message");
-		doAlertIcon = true;
-		break;
-	case AlertChat:
-		text += PsiPopup::tr("Incoming chat message");
-		icon= (PsiIcon *)IconsetFactory::iconPtr("psi/chat");
-		doAlertIcon = true;
-		break;
-	case AlertHeadline:
-		text += PsiPopup::tr("Headline");
-		icon= (PsiIcon *)IconsetFactory::iconPtr("psi/headline");
-		doAlertIcon = true;
-		break;
-	case AlertFile:
-		text += PsiPopup::tr("Incoming file");
-		icon= (PsiIcon *)IconsetFactory::iconPtr("psi/file");
-		doAlertIcon = true;
-		break;
-	case AlertAvCall:
-		text += PsiPopup::tr("Incoming call");
-		icon= (PsiIcon *)IconsetFactory::iconPtr("psi/call");
-		doAlertIcon = true;
+	case PopupManager::AlertOnline:
+		text = PsiPopup::tr("Contact online");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("status/online");
+		*doAlertIcon = false;
+		break;
+	case PopupManager::AlertOffline:
+		text = PsiPopup::tr("Contact offline");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("status/offline");
+		*doAlertIcon = false;
+		break;
+	case PopupManager::AlertStatusChange:
+		text = PsiPopup::tr("Status change");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("status/online");
+		*doAlertIcon = false;
+		break;
+	case PopupManager::AlertMessage:
+		text = PsiPopup::tr("Incoming message");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/message");
+		*doAlertIcon = true;
+		break;
+	case PopupManager::AlertComposing:
+		text = PsiPopup::tr("Typing notify");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/typing");
+		*doAlertIcon = false;
+		break;
+	case PopupManager::AlertChat:
+		text = PsiPopup::tr("Incoming chat message");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/chat");
+		*doAlertIcon = true;
+		break;
+	case PopupManager::AlertHeadline:
+		text = PsiPopup::tr("Headline");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/headline");
+		*doAlertIcon = true;
+		break;
+	case PopupManager::AlertFile:
+		text = PsiPopup::tr("Incoming file");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/file");
+		*doAlertIcon = true;
+		break;
+	case PopupManager::AlertAvCall:
+		text = PsiPopup::tr("Incoming call");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/call");
+		*doAlertIcon = true;
+		break;
+	case PopupManager::AlertGcHighlight:
+		text = PsiPopup::tr("Groupchat highlight");
+		*icon = (PsiIcon *)IconsetFactory::iconPtr("psi/headline");
+		*doAlertIcon = true;
 		break;
 	default:
 		break;
 	}
 
-	d->init(icon, text, acc, doAlertIcon ? type : AlertNone);
+	text = QString("%1: %2").arg(QApplication::applicationName(), text);
+
+	return text;
+}
+
+void PsiPopup::setJid(const Jid &j)
+{
+	d->jid = j;
 }
 
-void PsiPopup::setData(const QPixmap *avatar, const PsiIcon *icon, QString text)
+void PsiPopup::setData(const QPixmap *avatar, const PsiIcon *icon, const QString& text)
 {
 	if ( !d->popup ) {
 		deleteLater();
@@ -344,24 +338,26 @@ void PsiPopup::setData(const Jid &j, con
 
 	d->jid    = j;
 	d->status = r.status();
-	d->event  = (PsiEvent *)event;
+	if(d->popupType != PopupManager::AlertComposing)
+		d->event  = (PsiEvent *)event;
 
-	if ( event )
+	if ( d->event )
 		connect(event, SIGNAL(destroyed()), d, SLOT(eventDestroyed()));
 
 	PsiIcon *icon = PsiIconset::instance()->statusPtr(j, r.status());
-	QString text;
 
 	QString jid = j.full();
-	if ( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt() > 0 && ((int)jid.length()) > PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt() )
-		jid = jid.left( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt() ) + "...";
+	int jidLen = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt();
+	if (jidLen > 0 && ((int)jid.length()) > jidLen)
+		jid = jid.left(jidLen) + "...";
 
 	QString status;
-	if ( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt() != 0 )
+	int len = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt();
+	if (len != 0)
 		status = r.status().status();
-	if ( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt() > 0 )
-		if ( ((int)status.length()) > PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt() )
-			status = status.left ( PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-status-length").toInt() ) + "...";
+	if (len > 0)
+		if ( ((int)status.length()) > len )
+			status = status.left (len) + "...";
 
 	QString name;
 	if ( u && !u->name().isEmpty() ) {
@@ -375,7 +371,7 @@ void PsiPopup::setData(const Jid &j, con
 	}
 		
 	if (!name.isEmpty()) {
-		if ( !PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.maximum-jid-length").toInt() )
+		if (!jidLen)
 			name = "<nobr>" + Qt::escape(name) + "</nobr>";
 		else
 			name = "<nobr>" + Qt::escape(name) + " &lt;" + Qt::escape(jid) + "&gt;" + "</nobr>";
@@ -397,7 +393,7 @@ void PsiPopup::setData(const Jid &j, con
 	// hack for duplicate "Contact Online"/"Status Change" popups
 	foreach (PsiPopup *pp, *psiPopupList) {
 		if ( d->jid.full() == pp->d->jid.full() && d->status.show() == pp->d->status.show() && d->status.status() == d->status.status() ) {
-			if ( d->popupType == AlertStatusChange && pp->d->popupType == AlertOnline ) {
+			if ( d->popupType == PopupManager::AlertStatusChange && pp->d->popupType == PopupManager::AlertOnline ) {
 				d->display = false;
 				deleteLater();
 				break;
@@ -406,8 +402,9 @@ void PsiPopup::setData(const Jid &j, con
 	}
 	QPixmap avatar = d->account->avatarFactory()->getAvatar(jid);
 	// show popup
-	if ( d->popupType != AlertHeadline && (d->popupType != AlertFile || !PsiOptions::instance()->getOption("options.ui.file-transfer.auto-popup").toBool()) ) {
-
+	if ( d->popupType != PopupManager::AlertComposing && d->popupType != PopupManager::AlertHeadline &&
+	     (d->popupType != PopupManager::AlertFile || !PsiOptions::instance()->getOption("options.ui.file-transfer.auto-popup").toBool()) )
+	{
 		if ((event && event->type() == PsiEvent::Message) && (PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.showMessage").toBool())) {
 			const Message *jmessage = &((MessageEvent *)event)->message();
 			QString message;
@@ -420,11 +417,13 @@ void PsiPopup::setData(const Jid &j, con
 				contactText += "<br/><font size=\"+1\">" + message + "</font>";
 			}
 		}
-
-
                 setData(&avatar, icon, contactText);
 	}
-	else if ( d->popupType == AlertHeadline ) {
+	else if ( d->popupType == PopupManager::AlertComposing ) {
+		QString txt = "<font size=\"+1\">" + name + tr(" is typing...") + "</font>" ;
+		setData(&avatar, icon, txt);
+	}
+	else if ( d->popupType == PopupManager::AlertHeadline ) {
 		QVBoxLayout *vbox = new QVBoxLayout;
 		vbox->addLayout( d->createContactInfo(&avatar, icon, contactText) );
 
@@ -443,7 +442,7 @@ void PsiPopup::setData(const Jid &j, con
 
 		messageLabel->setWordWrap(true);
 		messageLabel->setTextFormat(Qt::RichText);
-		messageLabel->setText( d->clipText(TextUtil::linkify( message )) );
+		messageLabel->setText( PopupManager::clipText(TextUtil::linkify( message )) );
 		messageLabel->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
 		vbox->addWidget(messageLabel);
 
@@ -456,6 +455,9 @@ void PsiPopup::setData(const Jid &j, con
 		d->popup->addLayout( vbox );
 		show();
 	}
+	else {
+		deleteLater();
+	}
 }
 
 void PsiPopup::show()
--- psi.orig/src/psipopup.h
+++ psi/src/psipopup.h
@@ -21,57 +21,35 @@
 #ifndef PSIPOPUP_H
 #define PSIPOPUP_H
 
-#include <QObject>
-
-class QPixmap;
-class PsiCon;
-class PsiAccount;
-class UserListItem;
 class FancyPopup;
-class PsiIcon;
-class PsiEvent;
-namespace XMPP {
-	class Jid;
-	class Resource;
-}
-using namespace XMPP;
 
+#include "popupmanager.h"
 
 class PsiPopup : public QObject
 {
 	Q_OBJECT
 public:
-	PsiPopup(const PsiIcon *titleIcon, QString titleText, PsiAccount *acc);
-	~PsiPopup();
-
-	enum PopupType {
-		AlertNone = 0,
+	PsiPopup(PopupManager* manager, const PsiIcon *titleIcon, const QString& titleText, PsiAccount *acc, PopupManager::PopupType type);
+	PsiPopup(PopupManager* manager, PopupManager::PopupType type, PsiAccount *acc);
 
-		AlertOnline,
-		AlertOffline,
-		AlertStatusChange,
-
-		AlertMessage,
-		AlertChat,
-		AlertHeadline,
-		AlertFile,
-		AlertAvCall
-	};
-	PsiPopup(PopupType type, PsiAccount *acc);
+	~PsiPopup();
 
-	void setData(const QPixmap *avatar, const PsiIcon *icon, QString text);
 	void setData(const Jid &, const Resource &, const UserListItem * = 0, const PsiEvent * = 0);
+	void setData(const QPixmap *avatar, const PsiIcon *icon, const QString& text);
+
+	void setJid(const Jid &j);
 
 	void show();
+	static void deleteAll();
 
+	static QString title(PopupManager::PopupType type, bool *doAlertIcon, PsiIcon **icon);
+
+private:
 	QString id() const;
 	FancyPopup *popup();
 
-	static void deleteAll();
-
-public:
+	PopupManager* pm_;
 	class Private;
-private:
 	Private *d;
 	friend class Private;
 };
--- psi.orig/src/src.pri
+++ psi/src/src.pri
@@ -165,6 +165,7 @@ HEADERS += \
 	$$PWD/alerticon.h \
 	$$PWD/alertable.h \
 	$$PWD/psipopup.h \
+	$$PWD/popupmanager.h \
 	$$PWD/psiapplication.h \
 	$$PWD/filecache.h \
 	$$PWD/avatars.h \
@@ -308,6 +309,7 @@ SOURCES += \
 	$$PWD/alerticon.cpp \
 	$$PWD/alertable.cpp \
 	$$PWD/psipopup.cpp \
+	$$PWD/popupmanager.cpp \
 	$$PWD/psiapplication.cpp \
 	$$PWD/filecache.cpp \
 	$$PWD/avatars.cpp \
@@ -628,9 +630,11 @@ psi_plugins {
 }
 
 dbus {
-	HEADERS += 	$$PWD/dbus.h
+	HEADERS += 	$$PWD/dbus.h \
+			$$PWD/psidbusnotifier.h
 	SOURCES += 	$$PWD/dbus.cpp
-	SOURCES += $$PWD/activeprofiles_dbus.cpp
+	SOURCES +=	$$PWD/activeprofiles_dbus.cpp \
+			$$PWD/psidbusnotifier.cpp
 	DEFINES += USE_DBUS
 	CONFIG += qdbus
 }
--- psi.orig/src/widgets/fancypopup.cpp
+++ psi/src/widgets/fancypopup.cpp
@@ -19,15 +19,16 @@
  */
 
 #include "fancypopup.h"
+#include "ui_fancypopup.h"
 
-#include <QPixmap>
+//#include <QPixmap>
 #include <QApplication>
-#include <QLabel>
-#include <QLayout>
+//#include <QLabel>
+//#include <QLayout>
 #include <QTimer>
-#include <QPainter>
+//#include <QPainter>
 #include <QList>
-#include <QToolButton>
+//#include <QToolButton>
 #include <QStyle>
 #include <QDesktopWidget>
 #include <QMouseEvent>
@@ -35,7 +36,7 @@
 
 #include "iconset.h"
 #include "fancylabel.h"
-#include "iconlabel.h"
+//#include "iconlabel.h"
 #include "psitooltip.h"
 #include "psioptions.h"
 
@@ -73,7 +74,7 @@ public:
 
 	QPoint position();
 
-	class BackgroundWidget : public QWidget
+	/*class BackgroundWidget : public QWidget
 	{
 	public:
 		BackgroundWidget(QWidget *parent)
@@ -96,7 +97,7 @@ public:
 			p->drawTiledPixmap(0, 0, width(), height(), background);
 			delete p;
 		}
-	};
+	};*/
 
 	bool eventFilter(QObject *o, QEvent *e);
 
@@ -117,9 +118,10 @@ public:
 	PopupLayout popupLayout;
 
 	QList<FancyPopup *> prevPopups;
-	QBoxLayout *layout;
+	//QBoxLayout *layout;
 	FancyPopup *popup;
 	QTimer *hideTimer;
+	Ui::Frame ui_;
 };
 
 int  FancyPopup::Private::hideTimeout = 5 * 1000; // 5 seconds
@@ -187,7 +189,37 @@ void FancyPopup::Private::initContents(Q
 	QPixmap back(1, 1);
 	back.fill(backgroundColor);
 	
-	QVBoxLayout *vbox = new QVBoxLayout(popup);
+	ui_.setupUi(popup);
+	ui_.lb_bottom1->setPalette(backgroundPalette);
+	ui_.lb_icon->setPalette(backgroundPalette);
+	ui_.lb_mid1->setPalette(backgroundPalette);
+	ui_.lb_mid2->setPalette(backgroundPalette);
+	ui_.lb_top1->setPalette(backgroundPalette);
+	ui_.closeFrame->setPalette(backgroundPalette);
+
+	QBrush titleFontColor;
+	if ( (backgroundColor.red() + backgroundColor.green() + backgroundColor.blue())/3 > 128 )
+		titleFontColor = QBrush(Qt::white);
+	else
+		titleFontColor = QBrush(Qt::black);
+	QPalette titlePalette = backgroundPalette;
+	titlePalette.setBrush(QPalette::Text, titleFontColor);
+	ui_.lb_title->setPalette(titlePalette);
+	QFont titleFont = ui_.lb_title->font();
+	titleFont.setBold(true);
+	ui_.lb_title->setFont(titleFont);
+	ui_.lb_title->setText( title );
+
+	ui_.lb_icon->setPsiIcon(icon, copyIcon);
+
+	ui_.closeButton->setObjectName("closeButton");
+	ui_.closeButton->setToolTip(tr("Close"));
+	ui_.closeButton->setFocusPolicy( Qt::NoFocus );
+	ui_.closeButton->setIcon( popup->style()->standardPixmap(QStyle::SP_TitleBarCloseButton) );
+	ui_.closeButton->setFixedSize(BUTTON_WIDTH, BUTTON_HEIGHT);
+	connect(ui_.closeButton, SIGNAL(clicked()), popup, SLOT(hide()));
+
+	/*QVBoxLayout *vbox = new QVBoxLayout(popup);
 	vbox->setMargin(0);
 	vbox->setSpacing(0);
 
@@ -322,7 +354,7 @@ void FancyPopup::Private::initContents(Q
 	bottom3->setAutoFillBackground(true);
 	bottom3->setFixedSize( 4, 4 );
 	bottom3->setPalette(backgroundPalette);
-	bottomhbox->addWidget(bottom3);
+	bottomhbox->addWidget(bottom3);*/
 
 	const QString css = PsiOptions::instance()->getOption("options.ui.notifications.passive-popups.css").toString();
 	if (!css.isEmpty()) {
@@ -370,8 +402,8 @@ FancyPopup::~FancyPopup()
 
 void FancyPopup::addLayout(QLayout *layout, int stretch)
 {
-	d->layout->addLayout(layout, stretch);
-	d->layout->addSpacing(5);
+	d->ui_.layout->addLayout(layout, stretch);
+	d->ui_.layout->addSpacing(5);
 }
 
 void FancyPopup::show()
--- psi.orig/src/widgets/fancypopup.ui
+++ psi/src/widgets/fancypopup.ui
@@ -0,0 +1,777 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>Frame</class>
+ <widget class="QFrame" name="Frame">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>452</width>
+    <height>207</height>
+   </rect>
+  </property>
+  <property name="sizePolicy">
+   <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="minimumSize">
+   <size>
+    <width>0</width>
+    <height>10</height>
+   </size>
+  </property>
+  <property name="windowTitle">
+   <string>Frame</string>
+  </property>
+  <property name="frameShape">
+   <enum>QFrame::StyledPanel</enum>
+  </property>
+  <property name="frameShadow">
+   <enum>QFrame::Raised</enum>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <property name="spacing">
+    <number>0</number>
+   </property>
+   <property name="margin">
+    <number>0</number>
+   </property>
+   <item>
+    <layout class="QHBoxLayout" name="horizontalLayout_3">
+     <property name="spacing">
+      <number>0</number>
+     </property>
+     <property name="leftMargin">
+      <number>0</number>
+     </property>
+     <item>
+      <widget class="QLabel" name="lb_top1">
+       <property name="minimumSize">
+        <size>
+         <width>4</width>
+         <height>18</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>4</width>
+         <height>18</height>
+        </size>
+       </property>
+       <property name="palette">
+        <palette>
+         <active>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </active>
+         <inactive>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </inactive>
+         <disabled>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </disabled>
+        </palette>
+       </property>
+       <property name="autoFillBackground">
+        <bool>true</bool>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="IconLabel" name="lb_icon">
+       <property name="minimumSize">
+        <size>
+         <width>18</width>
+         <height>18</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>18</width>
+         <height>18</height>
+        </size>
+       </property>
+       <property name="palette">
+        <palette>
+         <active>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </active>
+         <inactive>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </inactive>
+         <disabled>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </disabled>
+        </palette>
+       </property>
+       <property name="autoFillBackground">
+        <bool>true</bool>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QLabel" name="lb_title">
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="minimumSize">
+        <size>
+         <width>0</width>
+         <height>18</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>16777215</width>
+         <height>18</height>
+        </size>
+       </property>
+       <property name="palette">
+        <palette>
+         <active>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </active>
+         <inactive>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </inactive>
+         <disabled>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </disabled>
+        </palette>
+       </property>
+       <property name="autoFillBackground">
+        <bool>true</bool>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QFrame" name="closeFrame">
+       <property name="palette">
+        <palette>
+         <active>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </active>
+         <inactive>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </inactive>
+         <disabled>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </disabled>
+        </palette>
+       </property>
+       <property name="autoFillBackground">
+        <bool>true</bool>
+       </property>
+       <property name="frameShape">
+        <enum>QFrame::NoFrame</enum>
+       </property>
+       <property name="frameShadow">
+        <enum>QFrame::Raised</enum>
+       </property>
+       <layout class="QHBoxLayout" name="horizontalLayout_4">
+        <property name="spacing">
+         <number>0</number>
+        </property>
+        <property name="leftMargin">
+         <number>9</number>
+        </property>
+        <property name="topMargin">
+         <number>0</number>
+        </property>
+        <property name="rightMargin">
+         <number>9</number>
+        </property>
+        <property name="bottomMargin">
+         <number>0</number>
+        </property>
+        <item>
+         <widget class="QToolButton" name="closeButton">
+          <property name="maximumSize">
+           <size>
+            <width>16</width>
+            <height>16</height>
+           </size>
+          </property>
+          <property name="text">
+           <string/>
+          </property>
+         </widget>
+        </item>
+       </layout>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="centralLayout">
+     <property name="spacing">
+      <number>6</number>
+     </property>
+     <property name="leftMargin">
+      <number>0</number>
+     </property>
+     <item>
+      <widget class="QLabel" name="lb_mid1">
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="minimumSize">
+        <size>
+         <width>4</width>
+         <height>20</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>4</width>
+         <height>16777215</height>
+        </size>
+       </property>
+       <property name="baseSize">
+        <size>
+         <width>4</width>
+         <height>0</height>
+        </size>
+       </property>
+       <property name="palette">
+        <palette>
+         <active>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </active>
+         <inactive>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </inactive>
+         <disabled>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </disabled>
+        </palette>
+       </property>
+       <property name="autoFillBackground">
+        <bool>true</bool>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <spacer name="horizontalSpacer_2">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeType">
+        <enum>QSizePolicy::Fixed</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>5</width>
+         <height>0</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <layout class="QHBoxLayout" name="layout">
+       <property name="spacing">
+        <number>0</number>
+       </property>
+       <item>
+        <spacer name="horizontalSpacer">
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>0</width>
+           <height>0</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </item>
+     <item>
+      <spacer name="horizontalSpacer_3">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeType">
+        <enum>QSizePolicy::Fixed</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>5</width>
+         <height>0</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="QLabel" name="lb_mid2">
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="minimumSize">
+        <size>
+         <width>4</width>
+         <height>0</height>
+        </size>
+       </property>
+       <property name="maximumSize">
+        <size>
+         <width>4</width>
+         <height>16777215</height>
+        </size>
+       </property>
+       <property name="palette">
+        <palette>
+         <active>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </active>
+         <inactive>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>255</red>
+             <green>255</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </inactive>
+         <disabled>
+          <colorrole role="Base">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+          <colorrole role="Window">
+           <brush brushstyle="SolidPattern">
+            <color alpha="255">
+             <red>0</red>
+             <green>0</green>
+             <blue>255</blue>
+            </color>
+           </brush>
+          </colorrole>
+         </disabled>
+        </palette>
+       </property>
+       <property name="autoFillBackground">
+        <bool>true</bool>
+       </property>
+       <property name="text">
+        <string/>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <widget class="QLabel" name="lb_bottom1">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
+       <horstretch>0</horstretch>
+       <verstretch>0</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="minimumSize">
+      <size>
+       <width>0</width>
+       <height>4</height>
+      </size>
+     </property>
+     <property name="maximumSize">
+      <size>
+       <width>16777215</width>
+       <height>4</height>
+      </size>
+     </property>
+     <property name="palette">
+      <palette>
+       <active>
+        <colorrole role="Base">
+         <brush brushstyle="SolidPattern">
+          <color alpha="255">
+           <red>255</red>
+           <green>255</green>
+           <blue>255</blue>
+          </color>
+         </brush>
+        </colorrole>
+        <colorrole role="Window">
+         <brush brushstyle="SolidPattern">
+          <color alpha="255">
+           <red>0</red>
+           <green>0</green>
+           <blue>255</blue>
+          </color>
+         </brush>
+        </colorrole>
+       </active>
+       <inactive>
+        <colorrole role="Base">
+         <brush brushstyle="SolidPattern">
+          <color alpha="255">
+           <red>255</red>
+           <green>255</green>
+           <blue>255</blue>
+          </color>
+         </brush>
+        </colorrole>
+        <colorrole role="Window">
+         <brush brushstyle="SolidPattern">
+          <color alpha="255">
+           <red>0</red>
+           <green>0</green>
+           <blue>255</blue>
+          </color>
+         </brush>
+        </colorrole>
+       </inactive>
+       <disabled>
+        <colorrole role="Base">
+         <brush brushstyle="SolidPattern">
+          <color alpha="255">
+           <red>0</red>
+           <green>0</green>
+           <blue>255</blue>
+          </color>
+         </brush>
+        </colorrole>
+        <colorrole role="Window">
+         <brush brushstyle="SolidPattern">
+          <color alpha="255">
+           <red>0</red>
+           <green>0</green>
+           <blue>255</blue>
+          </color>
+         </brush>
+        </colorrole>
+       </disabled>
+      </palette>
+     </property>
+     <property name="autoFillBackground">
+      <bool>true</bool>
+     </property>
+     <property name="text">
+      <string/>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>IconLabel</class>
+   <extends>QLabel</extends>
+   <header>iconlabel.h</header>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections/>
+</ui>
--- psi.orig/src/widgets/widgets.pri
+++ psi/src/widgets/widgets.pri
@@ -48,7 +48,8 @@ HEADERS += \
 	$$PWD/actionlineedit.h \
 	$$PWD/typeaheadfind.h
 
-FORMS += psiwindowheader.ui
+FORMS += psiwindowheader.ui \
+	$$PWD/fancypopup.ui
 
 # to remove dependency on iconset and stuff
 #DEFINES += WIDGET_PLUGIN
